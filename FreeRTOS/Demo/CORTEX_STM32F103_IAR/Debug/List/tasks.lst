###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       14/May/2018  20:56:17
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\gonglt\Downloads\FreeRTOSv10.0.1\FreeRTOS\Source\tasks.c
#    Command line =  
#        C:\Users\gonglt\Downloads\FreeRTOSv10.0.1\FreeRTOS\Source\tasks.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        C:\Users\gonglt\Downloads\FreeRTOSv10.0.1\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\List
#        --diag_suppress Pa082,pe191 -o
#        C:\Users\gonglt\Downloads\FreeRTOSv10.0.1\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I
#        C:\Users\gonglt\Downloads\FreeRTOSv10.0.1\FreeRTOS\Demo\CORTEX_STM32F103_IAR\.\
#        -I
#        C:\Users\gonglt\Downloads\FreeRTOSv10.0.1\FreeRTOS\Demo\CORTEX_STM32F103_IAR\STM32F10xFWLib\inc\
#        -I
#        C:\Users\gonglt\Downloads\FreeRTOSv10.0.1\FreeRTOS\Demo\CORTEX_STM32F103_IAR\..\..\Source\include\
#        -I
#        C:\Users\gonglt\Downloads\FreeRTOSv10.0.1\FreeRTOS\Demo\CORTEX_STM32F103_IAR\..\common\include\
#        -Ol --use_c++_inline --require_prototypes
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        C:\Users\gonglt\Downloads\FreeRTOSv10.0.1\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\List\tasks.lst
#    Object file  =  
#        C:\Users\gonglt\Downloads\FreeRTOSv10.0.1\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\Obj\tasks.o
#
###############################################################################

C:\Users\gonglt\Downloads\FreeRTOSv10.0.1\FreeRTOS\Source\tasks.c
      1          /*
      2           * FreeRTOS Kernel V10.0.1
      3           * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
      4           *
      5           * Permission is hereby granted, free of charge, to any person obtaining a copy of
      6           * this software and associated documentation files (the "Software"), to deal in
      7           * the Software without restriction, including without limitation the rights to
      8           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      9           * the Software, and to permit persons to whom the Software is furnished to do so,
     10           * subject to the following conditions:
     11           *
     12           * The above copyright notice and this permission notice shall be included in all
     13           * copies or substantial portions of the Software.
     14           *
     15           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     16           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     17           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     18           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     19           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     20           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     21           *
     22           * http://www.FreeRTOS.org
     23           * http://aws.amazon.com/freertos
     24           *
     25           * 1 tab == 4 spaces!
     26           */
     27          
     28          /* Standard includes. */
     29          #include <stdlib.h>
     30          #include <string.h>
     31          
     32          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     33          all the API functions to use the MPU wrappers.  That should only be done when
     34          task.h is included from an application file. */
     35          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     36          
     37          /* FreeRTOS includes. */
     38          #include "FreeRTOS.h"
     39          #include "task.h"
     40          #include "timers.h"
     41          #include "stack_macros.h"
     42          
     43          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     44          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     45          header files above, but not in this file, in order to generate the correct
     46          privileged Vs unprivileged linkage and placement. */
     47          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     48          
     49          /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
     50          functions but without including stdio.h here. */
     51          #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
     52          	/* At the bottom of this file are two optional functions that can be used
     53          	to generate human readable text from the raw data generated by the
     54          	uxTaskGetSystemState() function.  Note the formatting functions are provided
     55          	for convenience only, and are NOT considered part of the kernel. */
     56          	#include <stdio.h>
     57          #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
     58          
     59          #if( configUSE_PREEMPTION == 0 )
     60          	/* If the cooperative scheduler is being used then a yield should not be
     61          	performed just because a higher priority task has been woken. */
     62          	#define taskYIELD_IF_USING_PREEMPTION()
     63          #else
     64          	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
     65          #endif
     66          
     67          /* Values that can be assigned to the ucNotifyState member of the TCB. */
     68          #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
     69          #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
     70          #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
     71          
     72          /*
     73           * The value used to fill the stack of a task when the task is created.  This
     74           * is used purely for checking the high water mark for tasks.
     75           */
     76          #define tskSTACK_FILL_BYTE	( 0xa5U )
     77          
     78          /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
     79          dynamically allocated RAM, in which case when any task is deleted it is known
     80          that both the task's stack and TCB need to be freed.  Sometimes the
     81          FreeRTOSConfig.h settings only allow a task to be created using statically
     82          allocated RAM, in which case when any task is deleted it is known that neither
     83          the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
     84          settings allow a task to be created using either statically or dynamically
     85          allocated RAM, in which case a member of the TCB is used to record whether the
     86          stack and/or TCB were allocated statically or dynamically, so when a task is
     87          deleted the RAM that was allocated dynamically is freed again and no attempt is
     88          made to free the RAM that was allocated statically.
     89          tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
     90          task to be created using either statically or dynamically allocated RAM.  Note
     91          that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
     92          a statically allocated stack and a dynamically allocated TCB.
     93          !!!NOTE!!! If the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is
     94          changed then the definition of StaticTask_t must also be updated. */
     95          #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
     96          #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
     97          #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
     98          #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
     99          
    100          /* If any of the following are set then task stacks are filled with a known
    101          value so the high water mark can be determined.  If none of the following are
    102          set then don't fill the stack so there is no unnecessary dependency on memset. */
    103          #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    104          	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
    105          #else
    106          	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
    107          #endif
    108          
    109          /*
    110           * Macros used by vListTask to indicate which state a task is in.
    111           */
    112          #define tskRUNNING_CHAR		( 'X' )
    113          #define tskBLOCKED_CHAR		( 'B' )
    114          #define tskREADY_CHAR		( 'R' )
    115          #define tskDELETED_CHAR		( 'D' )
    116          #define tskSUSPENDED_CHAR	( 'S' )
    117          
    118          /*
    119           * Some kernel aware debuggers require the data the debugger needs access to be
    120           * global, rather than file scope.
    121           */
    122          #ifdef portREMOVE_STATIC_QUALIFIER
    123          	#define static
    124          #endif
    125          
    126          /* The name allocated to the Idle task.  This can be overridden by defining
    127          configIDLE_TASK_NAME in FreeRTOSConfig.h. */
    128          #ifndef configIDLE_TASK_NAME
    129          	#define configIDLE_TASK_NAME "IDLE"
    130          #endif
    131          
    132          #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
    133          
    134          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
    135          	performed in a generic way that is not optimised to any particular
    136          	microcontroller architecture. */
    137          
    138          	/* uxTopReadyPriority holds the priority of the highest priority ready
    139          	state task. */
    140          	#define taskRECORD_READY_PRIORITY( uxPriority )														\
    141          	{																									\
    142          		if( ( uxPriority ) > uxTopReadyPriority )														\
    143          		{																								\
    144          			uxTopReadyPriority = ( uxPriority );														\
    145          		}																								\
    146          	} /* taskRECORD_READY_PRIORITY */
    147          
    148          	/*-----------------------------------------------------------*/
    149          
    150          	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
    151          	{																									\
    152          	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
    153          																										\
    154          		/* Find the highest priority queue that contains ready tasks. */								\
    155          		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
    156          		{																								\
    157          			configASSERT( uxTopPriority );																\
    158          			--uxTopPriority;																			\
    159          		}																								\
    160          																										\
    161          		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
    162          		the	same priority get an equal share of the processor time. */									\
    163          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
    164          		uxTopReadyPriority = uxTopPriority;																\
    165          	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
    166          
    167          	/*-----------------------------------------------------------*/
    168          
    169          	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
    170          	they are only required when a port optimised method of task selection is
    171          	being used. */
    172          	#define taskRESET_READY_PRIORITY( uxPriority )
    173          	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    174          
    175          #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    176          
    177          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
    178          	performed in a way that is tailored to the particular microcontroller
    179          	architecture being used. */
    180          
    181          	/* A port optimised version is provided.  Call the port defined macros. */
    182          	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    183          
    184          	/*-----------------------------------------------------------*/
    185          
    186          	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
    187          	{																								\
    188          	UBaseType_t uxTopPriority;																		\
    189          																									\
    190          		/* Find the highest priority list that contains ready tasks. */								\
    191          		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
    192          		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
    193          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
    194          	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
    195          
    196          	/*-----------------------------------------------------------*/
    197          
    198          	/* A port optimised version is provided, call it only if the TCB being reset
    199          	is being referenced from a ready list.  If it is referenced from a delayed
    200          	or suspended list then it won't be in a ready list. */
    201          	#define taskRESET_READY_PRIORITY( uxPriority )														\
    202          	{																									\
    203          		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
    204          		{																								\
    205          			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
    206          		}																								\
    207          	}
    208          
    209          #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    210          
    211          /*-----------------------------------------------------------*/
    212          
    213          /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
    214          count overflows. */
    215          #define taskSWITCH_DELAYED_LISTS()																	\
    216          {																									\
    217          	List_t *pxTemp;																					\
    218          																									\
    219          	/* The delayed tasks list should be empty when the lists are switched. */						\
    220          	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
    221          																									\
    222          	pxTemp = pxDelayedTaskList;																		\
    223          	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
    224          	pxOverflowDelayedTaskList = pxTemp;																\
    225          	xNumOfOverflows++;																				\
    226          	prvResetNextTaskUnblockTime();																	\
    227          }
    228          
    229          /*-----------------------------------------------------------*/
    230          
    231          /*
    232           * Place the task represented by pxTCB into the appropriate ready list for
    233           * the task.  It is inserted at the end of the list.
    234           */
    235          #define prvAddTaskToReadyList( pxTCB )																\
    236          	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
    237          	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
    238          	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
    239          	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
    240          /*-----------------------------------------------------------*/
    241          
    242          /*
    243           * Several functions take an TaskHandle_t parameter that can optionally be NULL,
    244           * where NULL is used to indicate that the handle of the currently executing
    245           * task should be used in place of the parameter.  This macro simply checks to
    246           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
    247           */
    248          #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
    249          
    250          /* The item value of the event list item is normally used to hold the priority
    251          of the task to which it belongs (coded to allow it to be held in reverse
    252          priority order).  However, it is occasionally borrowed for other purposes.  It
    253          is important its value is not updated due to a task priority change while it is
    254          being used for another purpose.  The following bit definition is used to inform
    255          the scheduler that the value should not be changed - in which case it is the
    256          responsibility of whichever module is using the value to ensure it gets set back
    257          to its original value when it is released. */
    258          #if( configUSE_16_BIT_TICKS == 1 )
    259          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
    260          #else
    261          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
    262          #endif
    263          
    264          /*
    265           * Task control block.  A task control block (TCB) is allocated for each task,
    266           * and stores task state information, including a pointer to the task's context
    267           * (the task's run time environment, including register values)
    268           */
    269          typedef struct tskTaskControlBlock
    270          {
    271          	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
    272          
    273          	#if ( portUSING_MPU_WRAPPERS == 1 )
    274          		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    275          	#endif
    276          
    277          	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
    278          	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
    279          	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
    280          	StackType_t			*pxStack;			/*< Points to the start of the stack. */
    281          	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    282          
    283          	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
    284          		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
    285          	#endif
    286          
    287          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    288          		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    289          	#endif
    290          
    291          	#if ( configUSE_TRACE_FACILITY == 1 )
    292          		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
    293          		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
    294          	#endif
    295          
    296          	#if ( configUSE_MUTEXES == 1 )
    297          		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    298          		UBaseType_t		uxMutexesHeld;
    299          	#endif
    300          
    301          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    302          		TaskHookFunction_t pxTaskTag;
    303          	#endif
    304          
    305          	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
    306          		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
    307          	#endif
    308          
    309          	#if( configGENERATE_RUN_TIME_STATS == 1 )
    310          		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
    311          	#endif
    312          
    313          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
    314          		/* Allocate a Newlib reent structure that is specific to this task.
    315          		Note Newlib support has been included by popular demand, but is not
    316          		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
    317          		responsible for resulting newlib operation.  User must be familiar with
    318          		newlib and must provide system-wide implementations of the necessary
    319          		stubs. Be warned that (at the time of writing) the current newlib design
    320          		implements a system-wide malloc() that must be provided with locks. */
    321          		struct	_reent xNewLib_reent;
    322          	#endif
    323          
    324          	#if( configUSE_TASK_NOTIFICATIONS == 1 )
    325          		volatile uint32_t ulNotifiedValue;
    326          		volatile uint8_t ucNotifyState;
    327          	#endif
    328          
    329          	/* See the comments above the definition of
    330          	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
    331          	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
    332          		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
    333          	#endif
    334          
    335          	#if( INCLUDE_xTaskAbortDelay == 1 )
    336          		uint8_t ucDelayAborted;
    337          	#endif
    338          
    339          } tskTCB;
    340          
    341          /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
    342          below to enable the use of older kernel aware debuggers. */
    343          typedef tskTCB TCB_t;
    344          
    345          /*lint -save -e956 A manual analysis and inspection has been used to determine
    346          which static variables must be declared volatile. */
    347          
    348          PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
    349          
    350          /* Lists for ready and blocked tasks. --------------------*/
    351          PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
    352          PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
    353          PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
    354          PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
    355          PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
    356          PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
    357          
    358          #if( INCLUDE_vTaskDelete == 1 )
    359          
    360          	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
    361          	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
    362          
    363          #endif
    364          
    365          #if ( INCLUDE_vTaskSuspend == 1 )
    366          
    367          	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
    368          
    369          #endif
    370          
    371          /* Other file private variables. --------------------------------*/
    372          PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
    373          PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT;
    374          PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
    375          PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
    376          PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
    377          PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
    378          PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
    379          PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
    380          PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
    381          PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
    382          
    383          /* Context switches are held pending while the scheduler is suspended.  Also,
    384          interrupts must not manipulate the xStateListItem of a TCB, or any of the
    385          lists the xStateListItem can be referenced from, if the scheduler is suspended.
    386          If an interrupt needs to unblock a task while the scheduler is suspended then it
    387          moves the task's event list item into the xPendingReadyList, ready for the
    388          kernel to move the task from the pending ready list into the real ready list
    389          when the scheduler is unsuspended.  The pending ready list itself can only be
    390          accessed from a critical section. */
    391          PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
    392          
    393          #if ( configGENERATE_RUN_TIME_STATS == 1 )
    394          
    395          	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
    396          	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
    397          
    398          #endif
    399          
    400          /*lint -restore */
    401          
    402          /*-----------------------------------------------------------*/
    403          
    404          /* Callback function prototypes. --------------------------*/
    405          #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
    406          
    407          	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
    408          
    409          #endif
    410          
    411          #if( configUSE_TICK_HOOK > 0 )
    412          
    413          	extern void vApplicationTickHook( void );
    414          
    415          #endif
    416          
    417          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    418          
    419          	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize );
    420          
    421          #endif
    422          
    423          /* File private functions. --------------------------------*/
    424          
    425          /**
    426           * Utility task that simply returns pdTRUE if the task referenced by xTask is
    427           * currently in the Suspended state, or pdFALSE if the task referenced by xTask
    428           * is in any other state.
    429           */
    430          #if ( INCLUDE_vTaskSuspend == 1 )
    431          
    432          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
    433          
    434          #endif /* INCLUDE_vTaskSuspend */
    435          
    436          /*
    437           * Utility to ready all the lists used by the scheduler.  This is called
    438           * automatically upon the creation of the first task.
    439           */
    440          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
    441          
    442          /*
    443           * The idle task, which as all tasks is implemented as a never ending loop.
    444           * The idle task is automatically created and added to the ready lists upon
    445           * creation of the first user task.
    446           *
    447           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
    448           * language extensions.  The equivalent prototype for this function is:
    449           *
    450           * void prvIdleTask( void *pvParameters );
    451           *
    452           */
    453          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
    454          
    455          /*
    456           * Utility to free all memory allocated by the scheduler to hold a TCB,
    457           * including the stack pointed to by the TCB.
    458           *
    459           * This does not free memory allocated by the task itself (i.e. memory
    460           * allocated by calls to pvPortMalloc from within the tasks application code).
    461           */
    462          #if ( INCLUDE_vTaskDelete == 1 )
    463          
    464          	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
    465          
    466          #endif
    467          
    468          /*
    469           * Used only by the idle task.  This checks to see if anything has been placed
    470           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
    471           * and its TCB deleted.
    472           */
    473          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
    474          
    475          /*
    476           * The currently executing task is entering the Blocked state.  Add the task to
    477           * either the current or the overflow delayed task list.
    478           */
    479          static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
    480          
    481          /*
    482           * Fills an TaskStatus_t structure with information on each task that is
    483           * referenced from the pxList list (which may be a ready list, a delayed list,
    484           * a suspended list, etc.).
    485           *
    486           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
    487           * NORMAL APPLICATION CODE.
    488           */
    489          #if ( configUSE_TRACE_FACILITY == 1 )
    490          
    491          	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
    492          
    493          #endif
    494          
    495          /*
    496           * Searches pxList for a task with name pcNameToQuery - returning a handle to
    497           * the task if it is found, or NULL if the task is not found.
    498           */
    499          #if ( INCLUDE_xTaskGetHandle == 1 )
    500          
    501          	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
    502          
    503          #endif
    504          
    505          /*
    506           * When a task is created, the stack of the task is filled with a known value.
    507           * This function determines the 'high water mark' of the task stack by
    508           * determining how much of the stack remains at the original preset value.
    509           */
    510          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    511          
    512          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
    513          
    514          #endif
    515          
    516          /*
    517           * Return the amount of time, in ticks, that will pass before the kernel will
    518           * next move a task from the Blocked state to the Running state.
    519           *
    520           * This conditional compilation should use inequality to 0, not equality to 1.
    521           * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
    522           * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
    523           * set to a value other than 1.
    524           */
    525          #if ( configUSE_TICKLESS_IDLE != 0 )
    526          
    527          	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
    528          
    529          #endif
    530          
    531          /*
    532           * Set xNextTaskUnblockTime to the time at which the next Blocked state task
    533           * will exit the Blocked state.
    534           */
    535          static void prvResetNextTaskUnblockTime( void );
    536          
    537          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
    538          
    539          	/*
    540          	 * Helper function used to pad task names with spaces when printing out
    541          	 * human readable tables of task information.
    542          	 */
    543          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
    544          
    545          #endif
    546          
    547          /*
    548           * Called after a Task_t structure has been allocated either statically or
    549           * dynamically to fill in the structure's members.
    550           */
    551          static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
    552          									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    553          									const uint32_t ulStackDepth,
    554          									void * const pvParameters,
    555          									UBaseType_t uxPriority,
    556          									TaskHandle_t * const pxCreatedTask,
    557          									TCB_t *pxNewTCB,
    558          									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
    559          
    560          /*
    561           * Called after a new task has been created and initialised to place the task
    562           * under the control of the scheduler.
    563           */
    564          static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
    565          
    566          /*
    567           * freertos_tasks_c_additions_init() should only be called if the user definable
    568           * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
    569           * called by the function.
    570           */
    571          #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
    572          
    573          	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
    574          
    575          #endif
    576          
    577          /*-----------------------------------------------------------*/
    578          
    579          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    580          
    581          	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
    582          									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    583          									const uint32_t ulStackDepth,
    584          									void * const pvParameters,
    585          									UBaseType_t uxPriority,
    586          									StackType_t * const puxStackBuffer,
    587          									StaticTask_t * const pxTaskBuffer )
    588          	{
    589          	TCB_t *pxNewTCB;
    590          	TaskHandle_t xReturn;
    591          
    592          		configASSERT( puxStackBuffer != NULL );
    593          		configASSERT( pxTaskBuffer != NULL );
    594          
    595          		#if( configASSERT_DEFINED == 1 )
    596          		{
    597          			/* Sanity check that the size of the structure used to declare a
    598          			variable of type StaticTask_t equals the size of the real task
    599          			structure. */
    600          			volatile size_t xSize = sizeof( StaticTask_t );
    601          			configASSERT( xSize == sizeof( TCB_t ) );
    602          		}
    603          		#endif /* configASSERT_DEFINED */
    604          
    605          
    606          		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
    607          		{
    608          			/* The memory used for the task's TCB and stack are passed into this
    609          			function - use them. */
    610          			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
    611          			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
    612          
    613          			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
    614          			{
    615          				/* Tasks can be created statically or dynamically, so note this
    616          				task was created statically in case the task is later deleted. */
    617          				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
    618          			}
    619          			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    620          
    621          			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
    622          			prvAddNewTaskToReadyList( pxNewTCB );
    623          		}
    624          		else
    625          		{
    626          			xReturn = NULL;
    627          		}
    628          
    629          		return xReturn;
    630          	}
    631          
    632          #endif /* SUPPORT_STATIC_ALLOCATION */
    633          /*-----------------------------------------------------------*/
    634          
    635          #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    636          
    637          	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
    638          	{
    639          	TCB_t *pxNewTCB;
    640          	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    641          
    642          		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
    643          		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
    644          
    645          		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
    646          		{
    647          			/* Allocate space for the TCB.  Where the memory comes from depends
    648          			on the implementation of the port malloc function and whether or
    649          			not static allocation is being used. */
    650          			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
    651          
    652          			/* Store the stack location in the TCB. */
    653          			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
    654          
    655          			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
    656          			{
    657          				/* Tasks can be created statically or dynamically, so note this
    658          				task was created statically in case the task is later deleted. */
    659          				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
    660          			}
    661          			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    662          
    663          			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
    664          									pxTaskDefinition->pcName,
    665          									( uint32_t ) pxTaskDefinition->usStackDepth,
    666          									pxTaskDefinition->pvParameters,
    667          									pxTaskDefinition->uxPriority,
    668          									pxCreatedTask, pxNewTCB,
    669          									pxTaskDefinition->xRegions );
    670          
    671          			prvAddNewTaskToReadyList( pxNewTCB );
    672          			xReturn = pdPASS;
    673          		}
    674          
    675          		return xReturn;
    676          	}
    677          
    678          #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    679          /*-----------------------------------------------------------*/
    680          
    681          #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    682          
    683          	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
    684          	{
    685          	TCB_t *pxNewTCB;
    686          	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    687          
    688          		configASSERT( pxTaskDefinition->puxStackBuffer );
    689          
    690          		if( pxTaskDefinition->puxStackBuffer != NULL )
    691          		{
    692          			/* Allocate space for the TCB.  Where the memory comes from depends
    693          			on the implementation of the port malloc function and whether or
    694          			not static allocation is being used. */
    695          			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    696          
    697          			if( pxNewTCB != NULL )
    698          			{
    699          				/* Store the stack location in the TCB. */
    700          				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
    701          
    702          				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    703          				{
    704          					/* Tasks can be created statically or dynamically, so note
    705          					this task had a statically allocated stack in case it is
    706          					later deleted.  The TCB was allocated dynamically. */
    707          					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
    708          				}
    709          				#endif
    710          
    711          				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
    712          										pxTaskDefinition->pcName,
    713          										( uint32_t ) pxTaskDefinition->usStackDepth,
    714          										pxTaskDefinition->pvParameters,
    715          										pxTaskDefinition->uxPriority,
    716          										pxCreatedTask, pxNewTCB,
    717          										pxTaskDefinition->xRegions );
    718          
    719          				prvAddNewTaskToReadyList( pxNewTCB );
    720          				xReturn = pdPASS;
    721          			}
    722          		}
    723          
    724          		return xReturn;
    725          	}
    726          
    727          #endif /* portUSING_MPU_WRAPPERS */
    728          /*-----------------------------------------------------------*/
    729          
    730          #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    731          
    732          	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    733          							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    734          							const configSTACK_DEPTH_TYPE usStackDepth,
    735          							void * const pvParameters,
    736          							UBaseType_t uxPriority,
    737          							TaskHandle_t * const pxCreatedTask )
    738          	{
    739          	TCB_t *pxNewTCB;
    740          	BaseType_t xReturn;
    741          
    742          		/* If the stack grows down then allocate the stack then the TCB so the stack
    743          		does not grow into the TCB.  Likewise if the stack grows up then allocate
    744          		the TCB then the stack. */
    745          		#if( portSTACK_GROWTH > 0 )
    746          		{
    747          			/* Allocate space for the TCB.  Where the memory comes from depends on
    748          			the implementation of the port malloc function and whether or not static
    749          			allocation is being used. */
    750          			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    751          
    752          			if( pxNewTCB != NULL )
    753          			{
    754          				/* Allocate space for the stack used by the task being created.
    755          				The base of the stack memory stored in the TCB so the task can
    756          				be deleted later if required. */
    757          				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    758          
    759          				if( pxNewTCB->pxStack == NULL )
    760          				{
    761          					/* Could not allocate the stack.  Delete the allocated TCB. */
    762          					vPortFree( pxNewTCB );
    763          					pxNewTCB = NULL;
    764          				}
    765          			}
    766          		}
    767          		#else /* portSTACK_GROWTH */
    768          		{
    769          		StackType_t *pxStack;
    770          
    771          			/* Allocate space for the stack used by the task being created. */
    772          			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    773          
    774          			if( pxStack != NULL )
    775          			{
    776          				/* Allocate space for the TCB. */
    777          				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    778          
    779          				if( pxNewTCB != NULL )
    780          				{
    781          					/* Store the stack location in the TCB. */
    782          					pxNewTCB->pxStack = pxStack;
    783          				}
    784          				else
    785          				{
    786          					/* The stack cannot be used as the TCB was not created.  Free
    787          					it again. */
    788          					vPortFree( pxStack );
    789          				}
    790          			}
    791          			else
    792          			{
    793          				pxNewTCB = NULL;
    794          			}
    795          		}
    796          		#endif /* portSTACK_GROWTH */
    797          
    798          		if( pxNewTCB != NULL )
    799          		{
    800          			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
    801          			{
    802          				/* Tasks can be created statically or dynamically, so note this
    803          				task was created dynamically in case it is later deleted. */
    804          				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
    805          			}
    806          			#endif /* configSUPPORT_STATIC_ALLOCATION */
    807          
    808          			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    809          			prvAddNewTaskToReadyList( pxNewTCB );
    810          			xReturn = pdPASS;
    811          		}
    812          		else
    813          		{
    814          			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    815          		}
    816          
    817          		return xReturn;
    818          	}
    819          
    820          #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    821          /*-----------------------------------------------------------*/
    822          
    823          static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
    824          									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    825          									const uint32_t ulStackDepth,
    826          									void * const pvParameters,
    827          									UBaseType_t uxPriority,
    828          									TaskHandle_t * const pxCreatedTask,
    829          									TCB_t *pxNewTCB,
    830          									const MemoryRegion_t * const xRegions )
    831          {
    832          StackType_t *pxTopOfStack;
    833          UBaseType_t x;
    834          
    835          	#if( portUSING_MPU_WRAPPERS == 1 )
    836          		/* Should the task be created in privileged mode? */
    837          		BaseType_t xRunPrivileged;
    838          		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
    839          		{
    840          			xRunPrivileged = pdTRUE;
    841          		}
    842          		else
    843          		{
    844          			xRunPrivileged = pdFALSE;
    845          		}
    846          		uxPriority &= ~portPRIVILEGE_BIT;
    847          	#endif /* portUSING_MPU_WRAPPERS == 1 */
    848          
    849          	/* Avoid dependency on memset() if it is not required. */
    850          	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
    851          	{
    852          		/* Fill the stack with a known value to assist debugging. */
    853          		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    854          	}
    855          	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
    856          
    857          	/* Calculate the top of stack address.  This depends on whether the stack
    858          	grows from high memory to low (as per the 80x86) or vice versa.
    859          	portSTACK_GROWTH is used to make the result positive or negative as required
    860          	by the port. */
    861          	#if( portSTACK_GROWTH < 0 )
    862          	{
    863          		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    864          		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    865          
    866          		/* Check the alignment of the calculated top of stack is correct. */
    867          		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    868          
    869          		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
    870          		{
    871          			/* Also record the stack's high address, which may assist
    872          			debugging. */
    873          			pxNewTCB->pxEndOfStack = pxTopOfStack;
    874          		}
    875          		#endif /* configRECORD_STACK_HIGH_ADDRESS */
    876          	}
    877          	#else /* portSTACK_GROWTH */
    878          	{
    879          		pxTopOfStack = pxNewTCB->pxStack;
    880          
    881          		/* Check the alignment of the stack buffer is correct. */
    882          		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    883          
    884          		/* The other extreme of the stack space is required if stack checking is
    885          		performed. */
    886          		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    887          	}
    888          	#endif /* portSTACK_GROWTH */
    889          
    890          	/* Store the task name in the TCB. */
    891          	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    892          	{
    893          		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    894          
    895          		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
    896          		configMAX_TASK_NAME_LEN characters just in case the memory after the
    897          		string is not accessible (extremely unlikely). */
    898          		if( pcName[ x ] == 0x00 )
    899          		{
    900          			break;
    901          		}
    902          		else
    903          		{
    904          			mtCOVERAGE_TEST_MARKER();
    905          		}
    906          	}
    907          
    908          	/* Ensure the name string is terminated in the case that the string length
    909          	was greater or equal to configMAX_TASK_NAME_LEN. */
    910          	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    911          
    912          	/* This is used as an array index so must ensure it's not too large.  First
    913          	remove the privilege bit if one is present. */
    914          	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    915          	{
    916          		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    917          	}
    918          	else
    919          	{
    920          		mtCOVERAGE_TEST_MARKER();
    921          	}
    922          
    923          	pxNewTCB->uxPriority = uxPriority;
    924          	#if ( configUSE_MUTEXES == 1 )
    925          	{
    926          		pxNewTCB->uxBasePriority = uxPriority;
    927          		pxNewTCB->uxMutexesHeld = 0;
    928          	}
    929          	#endif /* configUSE_MUTEXES */
    930          
    931          	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    932          	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    933          
    934          	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
    935          	back to	the containing TCB from a generic item in a list. */
    936          	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    937          
    938          	/* Event lists are always in priority order. */
    939          	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    940          	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    941          
    942          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    943          	{
    944          		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
    945          	}
    946          	#endif /* portCRITICAL_NESTING_IN_TCB */
    947          
    948          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    949          	{
    950          		pxNewTCB->pxTaskTag = NULL;
    951          	}
    952          	#endif /* configUSE_APPLICATION_TASK_TAG */
    953          
    954          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
    955          	{
    956          		pxNewTCB->ulRunTimeCounter = 0UL;
    957          	}
    958          	#endif /* configGENERATE_RUN_TIME_STATS */
    959          
    960          	#if ( portUSING_MPU_WRAPPERS == 1 )
    961          	{
    962          		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
    963          	}
    964          	#else
    965          	{
    966          		/* Avoid compiler warning about unreferenced parameter. */
    967          		( void ) xRegions;
    968          	}
    969          	#endif
    970          
    971          	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
    972          	{
    973          		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
    974          		{
    975          			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
    976          		}
    977          	}
    978          	#endif
    979          
    980          	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
    981          	{
    982          		pxNewTCB->ulNotifiedValue = 0;
    983          		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    984          	}
    985          	#endif
    986          
    987          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
    988          	{
    989          		/* Initialise this task's Newlib reent structure. */
    990          		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
    991          	}
    992          	#endif
    993          
    994          	#if( INCLUDE_xTaskAbortDelay == 1 )
    995          	{
    996          		pxNewTCB->ucDelayAborted = pdFALSE;
    997          	}
    998          	#endif
    999          
   1000          	/* Initialize the TCB stack to look as if the task was already running,
   1001          	but had been interrupted by the scheduler.  The return address is set
   1002          	to the start of the task function. Once the stack has been initialised
   1003          	the top of stack variable is updated. */
   1004          	#if( portUSING_MPU_WRAPPERS == 1 )
   1005          	{
   1006          		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
   1007          	}
   1008          	#else /* portUSING_MPU_WRAPPERS */
   1009          	{
   1010          		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   1011          	}
   1012          	#endif /* portUSING_MPU_WRAPPERS */
   1013          
   1014          	if( ( void * ) pxCreatedTask != NULL )
   1015          	{
   1016          		/* Pass the handle out in an anonymous way.  The handle can be used to
   1017          		change the created task's priority, delete the created task, etc.*/
   1018          		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   1019          	}
   1020          	else
   1021          	{
   1022          		mtCOVERAGE_TEST_MARKER();
   1023          	}
   1024          }
   1025          /*-----------------------------------------------------------*/
   1026          
   1027          static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
   1028          {
   1029          	/* Ensure interrupts don't access the task lists while the lists are being
   1030          	updated. */
   1031          	taskENTER_CRITICAL();
   1032          	{
   1033          		uxCurrentNumberOfTasks++;
   1034          		if( pxCurrentTCB == NULL )
   1035          		{
   1036          			/* There are no other tasks, or all the other tasks are in
   1037          			the suspended state - make this the current task. */
   1038          			pxCurrentTCB = pxNewTCB;
   1039          
   1040          			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   1041          			{
   1042          				/* This is the first task to be created so do the preliminary
   1043          				initialisation required.  We will not recover if this call
   1044          				fails, but we will report the failure. */
   1045          				prvInitialiseTaskLists();
   1046          			}
   1047          			else
   1048          			{
   1049          				mtCOVERAGE_TEST_MARKER();
   1050          			}
   1051          		}
   1052          		else
   1053          		{
   1054          			/* If the scheduler is not already running, make this task the
   1055          			current task if it is the highest priority task to be created
   1056          			so far. */
   1057          			if( xSchedulerRunning == pdFALSE )
   1058          			{
   1059          				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   1060          				{
   1061          					pxCurrentTCB = pxNewTCB;
   1062          				}
   1063          				else
   1064          				{
   1065          					mtCOVERAGE_TEST_MARKER();
   1066          				}
   1067          			}
   1068          			else
   1069          			{
   1070          				mtCOVERAGE_TEST_MARKER();
   1071          			}
   1072          		}
   1073          
   1074          		uxTaskNumber++;
   1075          
   1076          		#if ( configUSE_TRACE_FACILITY == 1 )
   1077          		{
   1078          			/* Add a counter into the TCB for tracing only. */
   1079          			pxNewTCB->uxTCBNumber = uxTaskNumber;
   1080          		}
   1081          		#endif /* configUSE_TRACE_FACILITY */
   1082          		traceTASK_CREATE( pxNewTCB );
   1083          
   1084          		prvAddTaskToReadyList( pxNewTCB );
   1085          
   1086          		portSETUP_TCB( pxNewTCB );
   1087          	}
   1088          	taskEXIT_CRITICAL();
   1089          
   1090          	if( xSchedulerRunning != pdFALSE )
   1091          	{
   1092          		/* If the created task is of a higher priority than the current task
   1093          		then it should run now. */
   1094          		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   1095          		{
   1096          			taskYIELD_IF_USING_PREEMPTION();
   1097          		}
   1098          		else
   1099          		{
   1100          			mtCOVERAGE_TEST_MARKER();
   1101          		}
   1102          	}
   1103          	else
   1104          	{
   1105          		mtCOVERAGE_TEST_MARKER();
   1106          	}
   1107          }
   1108          /*-----------------------------------------------------------*/
   1109          
   1110          #if ( INCLUDE_vTaskDelete == 1 )
   1111          
   1112          	void vTaskDelete( TaskHandle_t xTaskToDelete )
   1113          	{
   1114          	TCB_t *pxTCB;
   1115          
   1116          		taskENTER_CRITICAL();
   1117          		{
   1118          			/* If null is passed in here then it is the calling task that is
   1119          			being deleted. */
   1120          			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
   1121          
   1122          			/* Remove task from the ready list. */
   1123          			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1124          			{
   1125          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1126          			}
   1127          			else
   1128          			{
   1129          				mtCOVERAGE_TEST_MARKER();
   1130          			}
   1131          
   1132          			/* Is the task waiting on an event also? */
   1133          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   1134          			{
   1135          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1136          			}
   1137          			else
   1138          			{
   1139          				mtCOVERAGE_TEST_MARKER();
   1140          			}
   1141          
   1142          			/* Increment the uxTaskNumber also so kernel aware debuggers can
   1143          			detect that the task lists need re-generating.  This is done before
   1144          			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
   1145          			not return. */
   1146          			uxTaskNumber++;
   1147          
   1148          			if( pxTCB == pxCurrentTCB )
   1149          			{
   1150          				/* A task is deleting itself.  This cannot complete within the
   1151          				task itself, as a context switch to another task is required.
   1152          				Place the task in the termination list.  The idle task will
   1153          				check the termination list and free up any memory allocated by
   1154          				the scheduler for the TCB and stack of the deleted task. */
   1155          				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
   1156          
   1157          				/* Increment the ucTasksDeleted variable so the idle task knows
   1158          				there is a task that has been deleted and that it should therefore
   1159          				check the xTasksWaitingTermination list. */
   1160          				++uxDeletedTasksWaitingCleanUp;
   1161          
   1162          				/* The pre-delete hook is primarily for the Windows simulator,
   1163          				in which Windows specific clean up operations are performed,
   1164          				after which it is not possible to yield away from this task -
   1165          				hence xYieldPending is used to latch that a context switch is
   1166          				required. */
   1167          				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
   1168          			}
   1169          			else
   1170          			{
   1171          				--uxCurrentNumberOfTasks;
   1172          				prvDeleteTCB( pxTCB );
   1173          
   1174          				/* Reset the next expected unblock time in case it referred to
   1175          				the task that has just been deleted. */
   1176          				prvResetNextTaskUnblockTime();
   1177          			}
   1178          
   1179          			traceTASK_DELETE( pxTCB );
   1180          		}
   1181          		taskEXIT_CRITICAL();
   1182          
   1183          		/* Force a reschedule if it is the currently running task that has just
   1184          		been deleted. */
   1185          		if( xSchedulerRunning != pdFALSE )
   1186          		{
   1187          			if( pxTCB == pxCurrentTCB )
   1188          			{
   1189          				configASSERT( uxSchedulerSuspended == 0 );
   1190          				portYIELD_WITHIN_API();
   1191          			}
   1192          			else
   1193          			{
   1194          				mtCOVERAGE_TEST_MARKER();
   1195          			}
   1196          		}
   1197          	}
   1198          
   1199          #endif /* INCLUDE_vTaskDelete */
   1200          /*-----------------------------------------------------------*/
   1201          
   1202          #if ( INCLUDE_vTaskDelayUntil == 1 )
   1203          
   1204          	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
   1205          	{
   1206          	TickType_t xTimeToWake;
   1207          	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
   1208          
   1209          		configASSERT( pxPreviousWakeTime );
   1210          		configASSERT( ( xTimeIncrement > 0U ) );
   1211          		configASSERT( uxSchedulerSuspended == 0 );
   1212          
   1213          		vTaskSuspendAll();
   1214          		{
   1215          			/* Minor optimisation.  The tick count cannot change in this
   1216          			block. */
   1217          			const TickType_t xConstTickCount = xTickCount;
   1218          
   1219          			/* Generate the tick time at which the task wants to wake. */
   1220          			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   1221          
   1222          			if( xConstTickCount < *pxPreviousWakeTime )
   1223          			{
   1224          				/* The tick count has overflowed since this function was
   1225          				lasted called.  In this case the only time we should ever
   1226          				actually delay is if the wake time has also	overflowed,
   1227          				and the wake time is greater than the tick time.  When this
   1228          				is the case it is as if neither time had overflowed. */
   1229          				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
   1230          				{
   1231          					xShouldDelay = pdTRUE;
   1232          				}
   1233          				else
   1234          				{
   1235          					mtCOVERAGE_TEST_MARKER();
   1236          				}
   1237          			}
   1238          			else
   1239          			{
   1240          				/* The tick time has not overflowed.  In this case we will
   1241          				delay if either the wake time has overflowed, and/or the
   1242          				tick time is less than the wake time. */
   1243          				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
   1244          				{
   1245          					xShouldDelay = pdTRUE;
   1246          				}
   1247          				else
   1248          				{
   1249          					mtCOVERAGE_TEST_MARKER();
   1250          				}
   1251          			}
   1252          
   1253          			/* Update the wake time ready for the next call. */
   1254          			*pxPreviousWakeTime = xTimeToWake;
   1255          
   1256          			if( xShouldDelay != pdFALSE )
   1257          			{
   1258          				traceTASK_DELAY_UNTIL( xTimeToWake );
   1259          
   1260          				/* prvAddCurrentTaskToDelayedList() needs the block time, not
   1261          				the time to wake, so subtract the current tick count. */
   1262          				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
   1263          			}
   1264          			else
   1265          			{
   1266          				mtCOVERAGE_TEST_MARKER();
   1267          			}
   1268          		}
   1269          		xAlreadyYielded = xTaskResumeAll();
   1270          
   1271          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
   1272          		have put ourselves to sleep. */
   1273          		if( xAlreadyYielded == pdFALSE )
   1274          		{
   1275          			portYIELD_WITHIN_API();
   1276          		}
   1277          		else
   1278          		{
   1279          			mtCOVERAGE_TEST_MARKER();
   1280          		}
   1281          	}
   1282          
   1283          #endif /* INCLUDE_vTaskDelayUntil */
   1284          /*-----------------------------------------------------------*/
   1285          
   1286          #if ( INCLUDE_vTaskDelay == 1 )
   1287          
   1288          	void vTaskDelay( const TickType_t xTicksToDelay )
   1289          	{
   1290          	BaseType_t xAlreadyYielded = pdFALSE;
   1291          
   1292          		/* A delay time of zero just forces a reschedule. */
   1293          		if( xTicksToDelay > ( TickType_t ) 0U )
   1294          		{
   1295          			configASSERT( uxSchedulerSuspended == 0 );
   1296          			vTaskSuspendAll();
   1297          			{
   1298          				traceTASK_DELAY();
   1299          
   1300          				/* A task that is removed from the event list while the
   1301          				scheduler is suspended will not get placed in the ready
   1302          				list or removed from the blocked list until the scheduler
   1303          				is resumed.
   1304          
   1305          				This task cannot be in an event list as it is the currently
   1306          				executing task. */
   1307          				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   1308          			}
   1309          			xAlreadyYielded = xTaskResumeAll();
   1310          		}
   1311          		else
   1312          		{
   1313          			mtCOVERAGE_TEST_MARKER();
   1314          		}
   1315          
   1316          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
   1317          		have put ourselves to sleep. */
   1318          		if( xAlreadyYielded == pdFALSE )
   1319          		{
   1320          			portYIELD_WITHIN_API();
   1321          		}
   1322          		else
   1323          		{
   1324          			mtCOVERAGE_TEST_MARKER();
   1325          		}
   1326          	}
   1327          
   1328          #endif /* INCLUDE_vTaskDelay */
   1329          /*-----------------------------------------------------------*/
   1330          
   1331          #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
   1332          
   1333          	eTaskState eTaskGetState( TaskHandle_t xTask )
   1334          	{
   1335          	eTaskState eReturn;
   1336          	List_t *pxStateList;
   1337          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
   1338          
   1339          		configASSERT( pxTCB );
   1340          
   1341          		if( pxTCB == pxCurrentTCB )
   1342          		{
   1343          			/* The task calling this function is querying its own state. */
   1344          			eReturn = eRunning;
   1345          		}
   1346          		else
   1347          		{
   1348          			taskENTER_CRITICAL();
   1349          			{
   1350          				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
   1351          			}
   1352          			taskEXIT_CRITICAL();
   1353          
   1354          			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
   1355          			{
   1356          				/* The task being queried is referenced from one of the Blocked
   1357          				lists. */
   1358          				eReturn = eBlocked;
   1359          			}
   1360          
   1361          			#if ( INCLUDE_vTaskSuspend == 1 )
   1362          				else if( pxStateList == &xSuspendedTaskList )
   1363          				{
   1364          					/* The task being queried is referenced from the suspended
   1365          					list.  Is it genuinely suspended or is it block
   1366          					indefinitely? */
   1367          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
   1368          					{
   1369          						eReturn = eSuspended;
   1370          					}
   1371          					else
   1372          					{
   1373          						eReturn = eBlocked;
   1374          					}
   1375          				}
   1376          			#endif
   1377          
   1378          			#if ( INCLUDE_vTaskDelete == 1 )
   1379          				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
   1380          				{
   1381          					/* The task being queried is referenced from the deleted
   1382          					tasks list, or it is not referenced from any lists at
   1383          					all. */
   1384          					eReturn = eDeleted;
   1385          				}
   1386          			#endif
   1387          
   1388          			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
   1389          			{
   1390          				/* If the task is not in any other state, it must be in the
   1391          				Ready (including pending ready) state. */
   1392          				eReturn = eReady;
   1393          			}
   1394          		}
   1395          
   1396          		return eReturn;
   1397          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1398          
   1399          #endif /* INCLUDE_eTaskGetState */
   1400          /*-----------------------------------------------------------*/
   1401          
   1402          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1403          
   1404          	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
   1405          	{
   1406          	TCB_t *pxTCB;
   1407          	UBaseType_t uxReturn;
   1408          
   1409          		taskENTER_CRITICAL();
   1410          		{
   1411          			/* If null is passed in here then it is the priority of the that
   1412          			called uxTaskPriorityGet() that is being queried. */
   1413          			pxTCB = prvGetTCBFromHandle( xTask );
   1414          			uxReturn = pxTCB->uxPriority;
   1415          		}
   1416          		taskEXIT_CRITICAL();
   1417          
   1418          		return uxReturn;
   1419          	}
   1420          
   1421          #endif /* INCLUDE_uxTaskPriorityGet */
   1422          /*-----------------------------------------------------------*/
   1423          
   1424          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1425          
   1426          	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
   1427          	{
   1428          	TCB_t *pxTCB;
   1429          	UBaseType_t uxReturn, uxSavedInterruptState;
   1430          
   1431          		/* RTOS ports that support interrupt nesting have the concept of a
   1432          		maximum	system call (or maximum API call) interrupt priority.
   1433          		Interrupts that are	above the maximum system call priority are keep
   1434          		permanently enabled, even when the RTOS kernel is in a critical section,
   1435          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1436          		is defined in FreeRTOSConfig.h then
   1437          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1438          		failure if a FreeRTOS API function is called from an interrupt that has
   1439          		been assigned a priority above the configured maximum system call
   1440          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1441          		from interrupts	that have been assigned a priority at or (logically)
   1442          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1443          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1444          		simple as possible.  More information (albeit Cortex-M specific) is
   1445          		provided on the following link:
   1446          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1447          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1448          
   1449          		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
   1450          		{
   1451          			/* If null is passed in here then it is the priority of the calling
   1452          			task that is being queried. */
   1453          			pxTCB = prvGetTCBFromHandle( xTask );
   1454          			uxReturn = pxTCB->uxPriority;
   1455          		}
   1456          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
   1457          
   1458          		return uxReturn;
   1459          	}
   1460          
   1461          #endif /* INCLUDE_uxTaskPriorityGet */
   1462          /*-----------------------------------------------------------*/
   1463          
   1464          #if ( INCLUDE_vTaskPrioritySet == 1 )
   1465          
   1466          	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
   1467          	{
   1468          	TCB_t *pxTCB;
   1469          	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
   1470          	BaseType_t xYieldRequired = pdFALSE;
   1471          
   1472          		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
   1473          
   1474          		/* Ensure the new priority is valid. */
   1475          		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   1476          		{
   1477          			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   1478          		}
   1479          		else
   1480          		{
   1481          			mtCOVERAGE_TEST_MARKER();
   1482          		}
   1483          
   1484          		taskENTER_CRITICAL();
   1485          		{
   1486          			/* If null is passed in here then it is the priority of the calling
   1487          			task that is being changed. */
   1488          			pxTCB = prvGetTCBFromHandle( xTask );
   1489          
   1490          			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
   1491          
   1492          			#if ( configUSE_MUTEXES == 1 )
   1493          			{
   1494          				uxCurrentBasePriority = pxTCB->uxBasePriority;
   1495          			}
   1496          			#else
   1497          			{
   1498          				uxCurrentBasePriority = pxTCB->uxPriority;
   1499          			}
   1500          			#endif
   1501          
   1502          			if( uxCurrentBasePriority != uxNewPriority )
   1503          			{
   1504          				/* The priority change may have readied a task of higher
   1505          				priority than the calling task. */
   1506          				if( uxNewPriority > uxCurrentBasePriority )
   1507          				{
   1508          					if( pxTCB != pxCurrentTCB )
   1509          					{
   1510          						/* The priority of a task other than the currently
   1511          						running task is being raised.  Is the priority being
   1512          						raised above that of the running task? */
   1513          						if( uxNewPriority >= pxCurrentTCB->uxPriority )
   1514          						{
   1515          							xYieldRequired = pdTRUE;
   1516          						}
   1517          						else
   1518          						{
   1519          							mtCOVERAGE_TEST_MARKER();
   1520          						}
   1521          					}
   1522          					else
   1523          					{
   1524          						/* The priority of the running task is being raised,
   1525          						but the running task must already be the highest
   1526          						priority task able to run so no yield is required. */
   1527          					}
   1528          				}
   1529          				else if( pxTCB == pxCurrentTCB )
   1530          				{
   1531          					/* Setting the priority of the running task down means
   1532          					there may now be another task of higher priority that
   1533          					is ready to execute. */
   1534          					xYieldRequired = pdTRUE;
   1535          				}
   1536          				else
   1537          				{
   1538          					/* Setting the priority of any other task down does not
   1539          					require a yield as the running task must be above the
   1540          					new priority of the task being modified. */
   1541          				}
   1542          
   1543          				/* Remember the ready list the task might be referenced from
   1544          				before its uxPriority member is changed so the
   1545          				taskRESET_READY_PRIORITY() macro can function correctly. */
   1546          				uxPriorityUsedOnEntry = pxTCB->uxPriority;
   1547          
   1548          				#if ( configUSE_MUTEXES == 1 )
   1549          				{
   1550          					/* Only change the priority being used if the task is not
   1551          					currently using an inherited priority. */
   1552          					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   1553          					{
   1554          						pxTCB->uxPriority = uxNewPriority;
   1555          					}
   1556          					else
   1557          					{
   1558          						mtCOVERAGE_TEST_MARKER();
   1559          					}
   1560          
   1561          					/* The base priority gets set whatever. */
   1562          					pxTCB->uxBasePriority = uxNewPriority;
   1563          				}
   1564          				#else
   1565          				{
   1566          					pxTCB->uxPriority = uxNewPriority;
   1567          				}
   1568          				#endif
   1569          
   1570          				/* Only reset the event list item value if the value is not
   1571          				being used for anything else. */
   1572          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   1573          				{
   1574          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1575          				}
   1576          				else
   1577          				{
   1578          					mtCOVERAGE_TEST_MARKER();
   1579          				}
   1580          
   1581          				/* If the task is in the blocked or suspended list we need do
   1582          				nothing more than change its priority variable. However, if
   1583          				the task is in a ready list it needs to be removed and placed
   1584          				in the list appropriate to its new priority. */
   1585          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   1586          				{
   1587          					/* The task is currently in its ready list - remove before
   1588          					adding it to it's new ready list.  As we are in a critical
   1589          					section we can do this even if the scheduler is suspended. */
   1590          					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1591          					{
   1592          						/* It is known that the task is in its ready list so
   1593          						there is no need to check again and the port level
   1594          						reset macro can be called directly. */
   1595          						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
   1596          					}
   1597          					else
   1598          					{
   1599          						mtCOVERAGE_TEST_MARKER();
   1600          					}
   1601          					prvAddTaskToReadyList( pxTCB );
   1602          				}
   1603          				else
   1604          				{
   1605          					mtCOVERAGE_TEST_MARKER();
   1606          				}
   1607          
   1608          				if( xYieldRequired != pdFALSE )
   1609          				{
   1610          					taskYIELD_IF_USING_PREEMPTION();
   1611          				}
   1612          				else
   1613          				{
   1614          					mtCOVERAGE_TEST_MARKER();
   1615          				}
   1616          
   1617          				/* Remove compiler warning about unused variables when the port
   1618          				optimised task selection is not being used. */
   1619          				( void ) uxPriorityUsedOnEntry;
   1620          			}
   1621          		}
   1622          		taskEXIT_CRITICAL();
   1623          	}
   1624          
   1625          #endif /* INCLUDE_vTaskPrioritySet */
   1626          /*-----------------------------------------------------------*/
   1627          
   1628          #if ( INCLUDE_vTaskSuspend == 1 )
   1629          
   1630          	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
   1631          	{
   1632          	TCB_t *pxTCB;
   1633          
   1634          		taskENTER_CRITICAL();
   1635          		{
   1636          			/* If null is passed in here then it is the running task that is
   1637          			being suspended. */
   1638          			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   1639          
   1640          			traceTASK_SUSPEND( pxTCB );
   1641          
   1642          			/* Remove task from the ready/delayed list and place in the
   1643          			suspended list. */
   1644          			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1645          			{
   1646          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1647          			}
   1648          			else
   1649          			{
   1650          				mtCOVERAGE_TEST_MARKER();
   1651          			}
   1652          
   1653          			/* Is the task waiting on an event also? */
   1654          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   1655          			{
   1656          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1657          			}
   1658          			else
   1659          			{
   1660          				mtCOVERAGE_TEST_MARKER();
   1661          			}
   1662          
   1663          			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
   1664          
   1665          			#if( configUSE_TASK_NOTIFICATIONS == 1 )
   1666          			{
   1667          				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
   1668          				{
   1669          					/* The task was blocked to wait for a notification, but is
   1670          					now suspended, so no notification was received. */
   1671          					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   1672          				}
   1673          			}
   1674          			#endif
   1675          		}
   1676          		taskEXIT_CRITICAL();
   1677          
   1678          		if( xSchedulerRunning != pdFALSE )
   1679          		{
   1680          			/* Reset the next expected unblock time in case it referred to the
   1681          			task that is now in the Suspended state. */
   1682          			taskENTER_CRITICAL();
   1683          			{
   1684          				prvResetNextTaskUnblockTime();
   1685          			}
   1686          			taskEXIT_CRITICAL();
   1687          		}
   1688          		else
   1689          		{
   1690          			mtCOVERAGE_TEST_MARKER();
   1691          		}
   1692          
   1693          		if( pxTCB == pxCurrentTCB )
   1694          		{
   1695          			if( xSchedulerRunning != pdFALSE )
   1696          			{
   1697          				/* The current task has just been suspended. */
   1698          				configASSERT( uxSchedulerSuspended == 0 );
   1699          				portYIELD_WITHIN_API();
   1700          			}
   1701          			else
   1702          			{
   1703          				/* The scheduler is not running, but the task that was pointed
   1704          				to by pxCurrentTCB has just been suspended and pxCurrentTCB
   1705          				must be adjusted to point to a different task. */
   1706          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
   1707          				{
   1708          					/* No other tasks are ready, so set pxCurrentTCB back to
   1709          					NULL so when the next task is created pxCurrentTCB will
   1710          					be set to point to it no matter what its relative priority
   1711          					is. */
   1712          					pxCurrentTCB = NULL;
   1713          				}
   1714          				else
   1715          				{
   1716          					vTaskSwitchContext();
   1717          				}
   1718          			}
   1719          		}
   1720          		else
   1721          		{
   1722          			mtCOVERAGE_TEST_MARKER();
   1723          		}
   1724          	}
   1725          
   1726          #endif /* INCLUDE_vTaskSuspend */
   1727          /*-----------------------------------------------------------*/
   1728          
   1729          #if ( INCLUDE_vTaskSuspend == 1 )
   1730          
   1731          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
   1732          	{
   1733          	BaseType_t xReturn = pdFALSE;
   1734          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
   1735          
   1736          		/* Accesses xPendingReadyList so must be called from a critical
   1737          		section. */
   1738          
   1739          		/* It does not make sense to check if the calling task is suspended. */
   1740          		configASSERT( xTask );
   1741          
   1742          		/* Is the task being resumed actually in the suspended list? */
   1743          		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
   1744          		{
   1745          			/* Has the task already been resumed from within an ISR? */
   1746          			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   1747          			{
   1748          				/* Is it in the suspended list because it is in the	Suspended
   1749          				state, or because is is blocked with no timeout? */
   1750          				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
   1751          				{
   1752          					xReturn = pdTRUE;
   1753          				}
   1754          				else
   1755          				{
   1756          					mtCOVERAGE_TEST_MARKER();
   1757          				}
   1758          			}
   1759          			else
   1760          			{
   1761          				mtCOVERAGE_TEST_MARKER();
   1762          			}
   1763          		}
   1764          		else
   1765          		{
   1766          			mtCOVERAGE_TEST_MARKER();
   1767          		}
   1768          
   1769          		return xReturn;
   1770          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1771          
   1772          #endif /* INCLUDE_vTaskSuspend */
   1773          /*-----------------------------------------------------------*/
   1774          
   1775          #if ( INCLUDE_vTaskSuspend == 1 )
   1776          
   1777          	void vTaskResume( TaskHandle_t xTaskToResume )
   1778          	{
   1779          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1780          
   1781          		/* It does not make sense to resume the calling task. */
   1782          		configASSERT( xTaskToResume );
   1783          
   1784          		/* The parameter cannot be NULL as it is impossible to resume the
   1785          		currently executing task. */
   1786          		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   1787          		{
   1788          			taskENTER_CRITICAL();
   1789          			{
   1790          				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   1791          				{
   1792          					traceTASK_RESUME( pxTCB );
   1793          
   1794          					/* The ready list can be accessed even if the scheduler is
   1795          					suspended because this is inside a critical section. */
   1796          					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
   1797          					prvAddTaskToReadyList( pxTCB );
   1798          
   1799          					/* A higher priority task may have just been resumed. */
   1800          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1801          					{
   1802          						/* This yield may not cause the task just resumed to run,
   1803          						but will leave the lists in the correct state for the
   1804          						next yield. */
   1805          						taskYIELD_IF_USING_PREEMPTION();
   1806          					}
   1807          					else
   1808          					{
   1809          						mtCOVERAGE_TEST_MARKER();
   1810          					}
   1811          				}
   1812          				else
   1813          				{
   1814          					mtCOVERAGE_TEST_MARKER();
   1815          				}
   1816          			}
   1817          			taskEXIT_CRITICAL();
   1818          		}
   1819          		else
   1820          		{
   1821          			mtCOVERAGE_TEST_MARKER();
   1822          		}
   1823          	}
   1824          
   1825          #endif /* INCLUDE_vTaskSuspend */
   1826          
   1827          /*-----------------------------------------------------------*/
   1828          
   1829          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
   1830          
   1831          	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
   1832          	{
   1833          	BaseType_t xYieldRequired = pdFALSE;
   1834          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1835          	UBaseType_t uxSavedInterruptStatus;
   1836          
   1837          		configASSERT( xTaskToResume );
   1838          
   1839          		/* RTOS ports that support interrupt nesting have the concept of a
   1840          		maximum	system call (or maximum API call) interrupt priority.
   1841          		Interrupts that are	above the maximum system call priority are keep
   1842          		permanently enabled, even when the RTOS kernel is in a critical section,
   1843          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1844          		is defined in FreeRTOSConfig.h then
   1845          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1846          		failure if a FreeRTOS API function is called from an interrupt that has
   1847          		been assigned a priority above the configured maximum system call
   1848          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1849          		from interrupts	that have been assigned a priority at or (logically)
   1850          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1851          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1852          		simple as possible.  More information (albeit Cortex-M specific) is
   1853          		provided on the following link:
   1854          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1855          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1856          
   1857          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1858          		{
   1859          			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   1860          			{
   1861          				traceTASK_RESUME_FROM_ISR( pxTCB );
   1862          
   1863          				/* Check the ready lists can be accessed. */
   1864          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1865          				{
   1866          					/* Ready lists can be accessed so move the task from the
   1867          					suspended list to the ready list directly. */
   1868          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1869          					{
   1870          						xYieldRequired = pdTRUE;
   1871          					}
   1872          					else
   1873          					{
   1874          						mtCOVERAGE_TEST_MARKER();
   1875          					}
   1876          
   1877          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   1878          					prvAddTaskToReadyList( pxTCB );
   1879          				}
   1880          				else
   1881          				{
   1882          					/* The delayed or ready lists cannot be accessed so the task
   1883          					is held in the pending ready list until the scheduler is
   1884          					unsuspended. */
   1885          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   1886          				}
   1887          			}
   1888          			else
   1889          			{
   1890          				mtCOVERAGE_TEST_MARKER();
   1891          			}
   1892          		}
   1893          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1894          
   1895          		return xYieldRequired;
   1896          	}
   1897          
   1898          #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
   1899          /*-----------------------------------------------------------*/
   1900          
   1901          void vTaskStartScheduler( void )
   1902          {
   1903          BaseType_t xReturn;
   1904          
   1905          	/* Add the idle task at the lowest priority. */
   1906          	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
   1907          	{
   1908          		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
   1909          		StackType_t *pxIdleTaskStackBuffer = NULL;
   1910          		uint32_t ulIdleTaskStackSize;
   1911          
   1912          		/* The Idle task is created using user provided RAM - obtain the
   1913          		address of the RAM then create the idle task. */
   1914          		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
   1915          		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
   1916          												configIDLE_TASK_NAME,
   1917          												ulIdleTaskStackSize,
   1918          												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
   1919          												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
   1920          												pxIdleTaskStackBuffer,
   1921          												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1922          
   1923          		if( xIdleTaskHandle != NULL )
   1924          		{
   1925          			xReturn = pdPASS;
   1926          		}
   1927          		else
   1928          		{
   1929          			xReturn = pdFAIL;
   1930          		}
   1931          	}
   1932          	#else
   1933          	{
   1934          		/* The Idle task is being created using dynamically allocated RAM. */
   1935          		xReturn = xTaskCreate(	prvIdleTask,
   1936          								configIDLE_TASK_NAME,
   1937          								configMINIMAL_STACK_SIZE,
   1938          								( void * ) NULL,
   1939          								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
   1940          								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1941          	}
   1942          	#endif /* configSUPPORT_STATIC_ALLOCATION */
   1943          
   1944          	#if ( configUSE_TIMERS == 1 )
   1945          	{
   1946          		if( xReturn == pdPASS )
   1947          		{
   1948          			xReturn = xTimerCreateTimerTask();
   1949          		}
   1950          		else
   1951          		{
   1952          			mtCOVERAGE_TEST_MARKER();
   1953          		}
   1954          	}
   1955          	#endif /* configUSE_TIMERS */
   1956          
   1957          	if( xReturn == pdPASS )
   1958          	{
   1959          		/* freertos_tasks_c_additions_init() should only be called if the user
   1960          		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
   1961          		the only macro called by the function. */
   1962          		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
   1963          		{
   1964          			freertos_tasks_c_additions_init();
   1965          		}
   1966          		#endif
   1967          
   1968          		/* Interrupts are turned off here, to ensure a tick does not occur
   1969          		before or during the call to xPortStartScheduler().  The stacks of
   1970          		the created tasks contain a status word with interrupts switched on
   1971          		so interrupts will automatically get re-enabled when the first task
   1972          		starts to run. */
   1973          		portDISABLE_INTERRUPTS();
   1974          
   1975          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   1976          		{
   1977          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   1978          			structure specific to the task that will run first. */
   1979          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   1980          		}
   1981          		#endif /* configUSE_NEWLIB_REENTRANT */
   1982          
   1983          		xNextTaskUnblockTime = portMAX_DELAY;
   1984          		xSchedulerRunning = pdTRUE;
   1985          		xTickCount = ( TickType_t ) 0U;
   1986          
   1987          		/* If configGENERATE_RUN_TIME_STATS is defined then the following
   1988          		macro must be defined to configure the timer/counter used to generate
   1989          		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
   1990          		is set to 0 and the following line fails to build then ensure you do not
   1991          		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
   1992          		FreeRTOSConfig.h file. */
   1993          		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   1994          
   1995          		/* Setting up the timer tick is hardware specific and thus in the
   1996          		portable interface. */
   1997          		if( xPortStartScheduler() != pdFALSE )
   1998          		{
   1999          			/* Should not reach here as if the scheduler is running the
   2000          			function will not return. */
   2001          		}
   2002          		else
   2003          		{
   2004          			/* Should only reach here if a task calls xTaskEndScheduler(). */
   2005          		}
   2006          	}
   2007          	else
   2008          	{
   2009          		/* This line will only be reached if the kernel could not be started,
   2010          		because there was not enough FreeRTOS heap to create the idle task
   2011          		or the timer task. */
   2012          		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
   2013          	}
   2014          
   2015          	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
   2016          	meaning xIdleTaskHandle is not used anywhere else. */
   2017          	( void ) xIdleTaskHandle;
   2018          }
   2019          /*-----------------------------------------------------------*/
   2020          
   2021          void vTaskEndScheduler( void )
   2022          {
   2023          	/* Stop the scheduler interrupts and call the portable scheduler end
   2024          	routine so the original ISRs can be restored if necessary.  The port
   2025          	layer must ensure interrupts enable	bit is left in the correct state. */
   2026          	portDISABLE_INTERRUPTS();
   2027          	xSchedulerRunning = pdFALSE;
   2028          	vPortEndScheduler();
   2029          }
   2030          /*----------------------------------------------------------*/
   2031          
   2032          void vTaskSuspendAll( void )
   2033          {
   2034          	/* A critical section is not required as the variable is of type
   2035          	BaseType_t.  Please read Richard Barry's reply in the following link to a
   2036          	post in the FreeRTOS support forum before reporting this as a bug! -
   2037          	http://goo.gl/wu4acr */
   2038          	++uxSchedulerSuspended;
   2039          }
   2040          /*----------------------------------------------------------*/
   2041          
   2042          #if ( configUSE_TICKLESS_IDLE != 0 )
   2043          
   2044          	static TickType_t prvGetExpectedIdleTime( void )
   2045          	{
   2046          	TickType_t xReturn;
   2047          	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
   2048          
   2049          		/* uxHigherPriorityReadyTasks takes care of the case where
   2050          		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
   2051          		task that are in the Ready state, even though the idle task is
   2052          		running. */
   2053          		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
   2054          		{
   2055          			if( uxTopReadyPriority > tskIDLE_PRIORITY )
   2056          			{
   2057          				uxHigherPriorityReadyTasks = pdTRUE;
   2058          			}
   2059          		}
   2060          		#else
   2061          		{
   2062          			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
   2063          
   2064          			/* When port optimised task selection is used the uxTopReadyPriority
   2065          			variable is used as a bit map.  If bits other than the least
   2066          			significant bit are set then there are tasks that have a priority
   2067          			above the idle priority that are in the Ready state.  This takes
   2068          			care of the case where the co-operative scheduler is in use. */
   2069          			if( uxTopReadyPriority > uxLeastSignificantBit )
   2070          			{
   2071          				uxHigherPriorityReadyTasks = pdTRUE;
   2072          			}
   2073          		}
   2074          		#endif
   2075          
   2076          		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
   2077          		{
   2078          			xReturn = 0;
   2079          		}
   2080          		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
   2081          		{
   2082          			/* There are other idle priority tasks in the ready state.  If
   2083          			time slicing is used then the very next tick interrupt must be
   2084          			processed. */
   2085          			xReturn = 0;
   2086          		}
   2087          		else if( uxHigherPriorityReadyTasks != pdFALSE )
   2088          		{
   2089          			/* There are tasks in the Ready state that have a priority above the
   2090          			idle priority.  This path can only be reached if
   2091          			configUSE_PREEMPTION is 0. */
   2092          			xReturn = 0;
   2093          		}
   2094          		else
   2095          		{
   2096          			xReturn = xNextTaskUnblockTime - xTickCount;
   2097          		}
   2098          
   2099          		return xReturn;
   2100          	}
   2101          
   2102          #endif /* configUSE_TICKLESS_IDLE */
   2103          /*----------------------------------------------------------*/
   2104          
   2105          BaseType_t xTaskResumeAll( void )
   2106          {
   2107          TCB_t *pxTCB = NULL;
   2108          BaseType_t xAlreadyYielded = pdFALSE;
   2109          
   2110          	/* If uxSchedulerSuspended is zero then this function does not match a
   2111          	previous call to vTaskSuspendAll(). */
   2112          	configASSERT( uxSchedulerSuspended );
   2113          
   2114          	/* It is possible that an ISR caused a task to be removed from an event
   2115          	list while the scheduler was suspended.  If this was the case then the
   2116          	removed task will have been added to the xPendingReadyList.  Once the
   2117          	scheduler has been resumed it is safe to move all the pending ready
   2118          	tasks from this list into their appropriate ready list. */
   2119          	taskENTER_CRITICAL();
   2120          	{
   2121          		--uxSchedulerSuspended;
   2122          
   2123          		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2124          		{
   2125          			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   2126          			{
   2127          				/* Move any readied tasks from the pending list into the
   2128          				appropriate ready list. */
   2129          				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   2130          				{
   2131          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   2132          					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2133          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   2134          					prvAddTaskToReadyList( pxTCB );
   2135          
   2136          					/* If the moved task has a priority higher than the current
   2137          					task then a yield must be performed. */
   2138          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   2139          					{
   2140          						xYieldPending = pdTRUE;
   2141          					}
   2142          					else
   2143          					{
   2144          						mtCOVERAGE_TEST_MARKER();
   2145          					}
   2146          				}
   2147          
   2148          				if( pxTCB != NULL )
   2149          				{
   2150          					/* A task was unblocked while the scheduler was suspended,
   2151          					which may have prevented the next unblock time from being
   2152          					re-calculated, in which case re-calculate it now.  Mainly
   2153          					important for low power tickless implementations, where
   2154          					this can prevent an unnecessary exit from low power
   2155          					state. */
   2156          					prvResetNextTaskUnblockTime();
   2157          				}
   2158          
   2159          				/* If any ticks occurred while the scheduler was suspended then
   2160          				they should be processed now.  This ensures the tick count does
   2161          				not	slip, and that any delayed tasks are resumed at the correct
   2162          				time. */
   2163          				{
   2164          					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   2165          
   2166          					if( uxPendedCounts > ( UBaseType_t ) 0U )
   2167          					{
   2168          						do
   2169          						{
   2170          							if( xTaskIncrementTick() != pdFALSE )
   2171          							{
   2172          								xYieldPending = pdTRUE;
   2173          							}
   2174          							else
   2175          							{
   2176          								mtCOVERAGE_TEST_MARKER();
   2177          							}
   2178          							--uxPendedCounts;
   2179          						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   2180          
   2181          						uxPendedTicks = 0;
   2182          					}
   2183          					else
   2184          					{
   2185          						mtCOVERAGE_TEST_MARKER();
   2186          					}
   2187          				}
   2188          
   2189          				if( xYieldPending != pdFALSE )
   2190          				{
   2191          					#if( configUSE_PREEMPTION != 0 )
   2192          					{
   2193          						xAlreadyYielded = pdTRUE;
   2194          					}
   2195          					#endif
   2196          					taskYIELD_IF_USING_PREEMPTION();
   2197          				}
   2198          				else
   2199          				{
   2200          					mtCOVERAGE_TEST_MARKER();
   2201          				}
   2202          			}
   2203          		}
   2204          		else
   2205          		{
   2206          			mtCOVERAGE_TEST_MARKER();
   2207          		}
   2208          	}
   2209          	taskEXIT_CRITICAL();
   2210          
   2211          	return xAlreadyYielded;
   2212          }
   2213          /*-----------------------------------------------------------*/
   2214          
   2215          TickType_t xTaskGetTickCount( void )
   2216          {
   2217          TickType_t xTicks;
   2218          
   2219          	/* Critical section required if running on a 16 bit processor. */
   2220          	portTICK_TYPE_ENTER_CRITICAL();
   2221          	{
   2222          		xTicks = xTickCount;
   2223          	}
   2224          	portTICK_TYPE_EXIT_CRITICAL();
   2225          
   2226          	return xTicks;
   2227          }
   2228          /*-----------------------------------------------------------*/
   2229          
   2230          TickType_t xTaskGetTickCountFromISR( void )
   2231          {
   2232          TickType_t xReturn;
   2233          UBaseType_t uxSavedInterruptStatus;
   2234          
   2235          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   2236          	system call (or maximum API call) interrupt priority.  Interrupts that are
   2237          	above the maximum system call priority are kept permanently enabled, even
   2238          	when the RTOS kernel is in a critical section, but cannot make any calls to
   2239          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   2240          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   2241          	failure if a FreeRTOS API function is called from an interrupt that has been
   2242          	assigned a priority above the configured maximum system call priority.
   2243          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   2244          	that have been assigned a priority at or (logically) below the maximum
   2245          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   2246          	safe API to ensure interrupt entry is as fast and as simple as possible.
   2247          	More information (albeit Cortex-M specific) is provided on the following
   2248          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   2249          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   2250          
   2251          	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
   2252          	{
   2253          		xReturn = xTickCount;
   2254          	}
   2255          	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   2256          
   2257          	return xReturn;
   2258          }
   2259          /*-----------------------------------------------------------*/
   2260          
   2261          UBaseType_t uxTaskGetNumberOfTasks( void )
   2262          {
   2263          	/* A critical section is not required because the variables are of type
   2264          	BaseType_t. */
   2265          	return uxCurrentNumberOfTasks;
   2266          }
   2267          /*-----------------------------------------------------------*/
   2268          
   2269          char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2270          {
   2271          TCB_t *pxTCB;
   2272          
   2273          	/* If null is passed in here then the name of the calling task is being
   2274          	queried. */
   2275          	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   2276          	configASSERT( pxTCB );
   2277          	return &( pxTCB->pcTaskName[ 0 ] );
   2278          }
   2279          /*-----------------------------------------------------------*/
   2280          
   2281          #if ( INCLUDE_xTaskGetHandle == 1 )
   2282          
   2283          	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
   2284          	{
   2285          	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
   2286          	UBaseType_t x;
   2287          	char cNextChar;
   2288          
   2289          		/* This function is called with the scheduler suspended. */
   2290          
   2291          		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   2292          		{
   2293          			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   2294          
   2295          			do
   2296          			{
   2297          				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   2298          
   2299          				/* Check each character in the name looking for a match or
   2300          				mismatch. */
   2301          				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   2302          				{
   2303          					cNextChar = pxNextTCB->pcTaskName[ x ];
   2304          
   2305          					if( cNextChar != pcNameToQuery[ x ] )
   2306          					{
   2307          						/* Characters didn't match. */
   2308          						break;
   2309          					}
   2310          					else if( cNextChar == 0x00 )
   2311          					{
   2312          						/* Both strings terminated, a match must have been
   2313          						found. */
   2314          						pxReturn = pxNextTCB;
   2315          						break;
   2316          					}
   2317          					else
   2318          					{
   2319          						mtCOVERAGE_TEST_MARKER();
   2320          					}
   2321          				}
   2322          
   2323          				if( pxReturn != NULL )
   2324          				{
   2325          					/* The handle has been found. */
   2326          					break;
   2327          				}
   2328          
   2329          			} while( pxNextTCB != pxFirstTCB );
   2330          		}
   2331          		else
   2332          		{
   2333          			mtCOVERAGE_TEST_MARKER();
   2334          		}
   2335          
   2336          		return pxReturn;
   2337          	}
   2338          
   2339          #endif /* INCLUDE_xTaskGetHandle */
   2340          /*-----------------------------------------------------------*/
   2341          
   2342          #if ( INCLUDE_xTaskGetHandle == 1 )
   2343          
   2344          	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2345          	{
   2346          	UBaseType_t uxQueue = configMAX_PRIORITIES;
   2347          	TCB_t* pxTCB;
   2348          
   2349          		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
   2350          		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
   2351          
   2352          		vTaskSuspendAll();
   2353          		{
   2354          			/* Search the ready lists. */
   2355          			do
   2356          			{
   2357          				uxQueue--;
   2358          				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
   2359          
   2360          				if( pxTCB != NULL )
   2361          				{
   2362          					/* Found the handle. */
   2363          					break;
   2364          				}
   2365          
   2366          			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2367          
   2368          			/* Search the delayed lists. */
   2369          			if( pxTCB == NULL )
   2370          			{
   2371          				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
   2372          			}
   2373          
   2374          			if( pxTCB == NULL )
   2375          			{
   2376          				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
   2377          			}
   2378          
   2379          			#if ( INCLUDE_vTaskSuspend == 1 )
   2380          			{
   2381          				if( pxTCB == NULL )
   2382          				{
   2383          					/* Search the suspended list. */
   2384          					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
   2385          				}
   2386          			}
   2387          			#endif
   2388          
   2389          			#if( INCLUDE_vTaskDelete == 1 )
   2390          			{
   2391          				if( pxTCB == NULL )
   2392          				{
   2393          					/* Search the deleted list. */
   2394          					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
   2395          				}
   2396          			}
   2397          			#endif
   2398          		}
   2399          		( void ) xTaskResumeAll();
   2400          
   2401          		return ( TaskHandle_t ) pxTCB;
   2402          	}
   2403          
   2404          #endif /* INCLUDE_xTaskGetHandle */
   2405          /*-----------------------------------------------------------*/
   2406          
   2407          #if ( configUSE_TRACE_FACILITY == 1 )
   2408          
   2409          	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
   2410          	{
   2411          	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
   2412          
   2413          		vTaskSuspendAll();
   2414          		{
   2415          			/* Is there a space in the array for each task in the system? */
   2416          			if( uxArraySize >= uxCurrentNumberOfTasks )
   2417          			{
   2418          				/* Fill in an TaskStatus_t structure with information on each
   2419          				task in the Ready state. */
   2420          				do
   2421          				{
   2422          					uxQueue--;
   2423          					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
   2424          
   2425          				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2426          
   2427          				/* Fill in an TaskStatus_t structure with information on each
   2428          				task in the Blocked state. */
   2429          				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
   2430          				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
   2431          
   2432          				#if( INCLUDE_vTaskDelete == 1 )
   2433          				{
   2434          					/* Fill in an TaskStatus_t structure with information on
   2435          					each task that has been deleted but not yet cleaned up. */
   2436          					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
   2437          				}
   2438          				#endif
   2439          
   2440          				#if ( INCLUDE_vTaskSuspend == 1 )
   2441          				{
   2442          					/* Fill in an TaskStatus_t structure with information on
   2443          					each task in the Suspended state. */
   2444          					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
   2445          				}
   2446          				#endif
   2447          
   2448          				#if ( configGENERATE_RUN_TIME_STATS == 1)
   2449          				{
   2450          					if( pulTotalRunTime != NULL )
   2451          					{
   2452          						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   2453          							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
   2454          						#else
   2455          							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   2456          						#endif
   2457          					}
   2458          				}
   2459          				#else
   2460          				{
   2461          					if( pulTotalRunTime != NULL )
   2462          					{
   2463          						*pulTotalRunTime = 0;
   2464          					}
   2465          				}
   2466          				#endif
   2467          			}
   2468          			else
   2469          			{
   2470          				mtCOVERAGE_TEST_MARKER();
   2471          			}
   2472          		}
   2473          		( void ) xTaskResumeAll();
   2474          
   2475          		return uxTask;
   2476          	}
   2477          
   2478          #endif /* configUSE_TRACE_FACILITY */
   2479          /*----------------------------------------------------------*/
   2480          
   2481          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   2482          
   2483          	TaskHandle_t xTaskGetIdleTaskHandle( void )
   2484          	{
   2485          		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
   2486          		started, then xIdleTaskHandle will be NULL. */
   2487          		configASSERT( ( xIdleTaskHandle != NULL ) );
   2488          		return xIdleTaskHandle;
   2489          	}
   2490          
   2491          #endif /* INCLUDE_xTaskGetIdleTaskHandle */
   2492          /*----------------------------------------------------------*/
   2493          
   2494          /* This conditional compilation should use inequality to 0, not equality to 1.
   2495          This is to ensure vTaskStepTick() is available when user defined low power mode
   2496          implementations require configUSE_TICKLESS_IDLE to be set to a value other than
   2497          1. */
   2498          #if ( configUSE_TICKLESS_IDLE != 0 )
   2499          
   2500          	void vTaskStepTick( const TickType_t xTicksToJump )
   2501          	{
   2502          		/* Correct the tick count value after a period during which the tick
   2503          		was suppressed.  Note this does *not* call the tick hook function for
   2504          		each stepped tick. */
   2505          		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
   2506          		xTickCount += xTicksToJump;
   2507          		traceINCREASE_TICK_COUNT( xTicksToJump );
   2508          	}
   2509          
   2510          #endif /* configUSE_TICKLESS_IDLE */
   2511          /*----------------------------------------------------------*/
   2512          
   2513          #if ( INCLUDE_xTaskAbortDelay == 1 )
   2514          
   2515          	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
   2516          	{
   2517          	TCB_t *pxTCB = ( TCB_t * ) xTask;
   2518          	BaseType_t xReturn;
   2519          
   2520          		configASSERT( pxTCB );
   2521          
   2522          		vTaskSuspendAll();
   2523          		{
   2524          			/* A task can only be prematurely removed from the Blocked state if
   2525          			it is actually in the Blocked state. */
   2526          			if( eTaskGetState( xTask ) == eBlocked )
   2527          			{
   2528          				xReturn = pdPASS;
   2529          
   2530          				/* Remove the reference to the task from the blocked list.  An
   2531          				interrupt won't touch the xStateListItem because the
   2532          				scheduler is suspended. */
   2533          				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   2534          
   2535          				/* Is the task waiting on an event also?  If so remove it from
   2536          				the event list too.  Interrupts can touch the event list item,
   2537          				even though the scheduler is suspended, so a critical section
   2538          				is used. */
   2539          				taskENTER_CRITICAL();
   2540          				{
   2541          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   2542          					{
   2543          						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2544          						pxTCB->ucDelayAborted = pdTRUE;
   2545          					}
   2546          					else
   2547          					{
   2548          						mtCOVERAGE_TEST_MARKER();
   2549          					}
   2550          				}
   2551          				taskEXIT_CRITICAL();
   2552          
   2553          				/* Place the unblocked task into the appropriate ready list. */
   2554          				prvAddTaskToReadyList( pxTCB );
   2555          
   2556          				/* A task being unblocked cannot cause an immediate context
   2557          				switch if preemption is turned off. */
   2558          				#if (  configUSE_PREEMPTION == 1 )
   2559          				{
   2560          					/* Preemption is on, but a context switch should only be
   2561          					performed if the unblocked task has a priority that is
   2562          					equal to or higher than the currently executing task. */
   2563          					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   2564          					{
   2565          						/* Pend the yield to be performed when the scheduler
   2566          						is unsuspended. */
   2567          						xYieldPending = pdTRUE;
   2568          					}
   2569          					else
   2570          					{
   2571          						mtCOVERAGE_TEST_MARKER();
   2572          					}
   2573          				}
   2574          				#endif /* configUSE_PREEMPTION */
   2575          			}
   2576          			else
   2577          			{
   2578          				xReturn = pdFAIL;
   2579          			}
   2580          		}
   2581          		( void ) xTaskResumeAll();
   2582          
   2583          		return xReturn;
   2584          	}
   2585          
   2586          #endif /* INCLUDE_xTaskAbortDelay */
   2587          /*----------------------------------------------------------*/
   2588          
   2589          BaseType_t xTaskIncrementTick( void )
   2590          {
   2591          TCB_t * pxTCB;
   2592          TickType_t xItemValue;
   2593          BaseType_t xSwitchRequired = pdFALSE;
   2594          
   2595          	/* Called by the portable layer each time a tick interrupt occurs.
   2596          	Increments the tick then checks to see if the new tick value will cause any
   2597          	tasks to be unblocked. */
   2598          	traceTASK_INCREMENT_TICK( xTickCount );
   2599          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2600          	{
   2601          		/* Minor optimisation.  The tick count cannot change in this
   2602          		block. */
   2603          		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   2604          
   2605          		/* Increment the RTOS tick, switching the delayed and overflowed
   2606          		delayed lists if it wraps to 0. */
   2607          		xTickCount = xConstTickCount;
   2608          
   2609          		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   2610          		{
   2611          			taskSWITCH_DELAYED_LISTS();
   2612          		}
   2613          		else
   2614          		{
   2615          			mtCOVERAGE_TEST_MARKER();
   2616          		}
   2617          
   2618          		/* See if this tick has made a timeout expire.  Tasks are stored in
   2619          		the	queue in the order of their wake time - meaning once one task
   2620          		has been found whose block time has not expired there is no need to
   2621          		look any further down the list. */
   2622          		if( xConstTickCount >= xNextTaskUnblockTime )
   2623          		{
   2624          			for( ;; )
   2625          			{
   2626          				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   2627          				{
   2628          					/* The delayed list is empty.  Set xNextTaskUnblockTime
   2629          					to the maximum possible value so it is extremely
   2630          					unlikely that the
   2631          					if( xTickCount >= xNextTaskUnblockTime ) test will pass
   2632          					next time through. */
   2633          					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2634          					break;
   2635          				}
   2636          				else
   2637          				{
   2638          					/* The delayed list is not empty, get the value of the
   2639          					item at the head of the delayed list.  This is the time
   2640          					at which the task at the head of the delayed list must
   2641          					be removed from the Blocked state. */
   2642          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   2643          					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   2644          
   2645          					if( xConstTickCount < xItemValue )
   2646          					{
   2647          						/* It is not time to unblock this item yet, but the
   2648          						item value is the time at which the task at the head
   2649          						of the blocked list must be removed from the Blocked
   2650          						state -	so record the item value in
   2651          						xNextTaskUnblockTime. */
   2652          						xNextTaskUnblockTime = xItemValue;
   2653          						break;
   2654          					}
   2655          					else
   2656          					{
   2657          						mtCOVERAGE_TEST_MARKER();
   2658          					}
   2659          
   2660          					/* It is time to remove the item from the Blocked state. */
   2661          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   2662          
   2663          					/* Is the task waiting on an event also?  If so remove
   2664          					it from the event list. */
   2665          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   2666          					{
   2667          						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2668          					}
   2669          					else
   2670          					{
   2671          						mtCOVERAGE_TEST_MARKER();
   2672          					}
   2673          
   2674          					/* Place the unblocked task into the appropriate ready
   2675          					list. */
   2676          					prvAddTaskToReadyList( pxTCB );
   2677          
   2678          					/* A task being unblocked cannot cause an immediate
   2679          					context switch if preemption is turned off. */
   2680          					#if (  configUSE_PREEMPTION == 1 )
   2681          					{
   2682          						/* Preemption is on, but a context switch should
   2683          						only be performed if the unblocked task has a
   2684          						priority that is equal to or higher than the
   2685          						currently executing task. */
   2686          						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   2687          						{
   2688          							xSwitchRequired = pdTRUE;
   2689          						}
   2690          						else
   2691          						{
   2692          							mtCOVERAGE_TEST_MARKER();
   2693          						}
   2694          					}
   2695          					#endif /* configUSE_PREEMPTION */
   2696          				}
   2697          			}
   2698          		}
   2699          
   2700          		/* Tasks of equal priority to the currently running task will share
   2701          		processing time (time slice) if preemption is on, and the application
   2702          		writer has not explicitly turned time slicing off. */
   2703          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
   2704          		{
   2705          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   2706          			{
   2707          				xSwitchRequired = pdTRUE;
   2708          			}
   2709          			else
   2710          			{
   2711          				mtCOVERAGE_TEST_MARKER();
   2712          			}
   2713          		}
   2714          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
   2715          
   2716          		#if ( configUSE_TICK_HOOK == 1 )
   2717          		{
   2718          			/* Guard against the tick hook being called when the pended tick
   2719          			count is being unwound (when the scheduler is being unlocked). */
   2720          			if( uxPendedTicks == ( UBaseType_t ) 0U )
   2721          			{
   2722          				vApplicationTickHook();
   2723          			}
   2724          			else
   2725          			{
   2726          				mtCOVERAGE_TEST_MARKER();
   2727          			}
   2728          		}
   2729          		#endif /* configUSE_TICK_HOOK */
   2730          	}
   2731          	else
   2732          	{
   2733          		++uxPendedTicks;
   2734          
   2735          		/* The tick hook gets called at regular intervals, even if the
   2736          		scheduler is locked. */
   2737          		#if ( configUSE_TICK_HOOK == 1 )
   2738          		{
   2739          			vApplicationTickHook();
   2740          		}
   2741          		#endif
   2742          	}
   2743          
   2744          	#if ( configUSE_PREEMPTION == 1 )
   2745          	{
   2746          		if( xYieldPending != pdFALSE )
   2747          		{
   2748          			xSwitchRequired = pdTRUE;
   2749          		}
   2750          		else
   2751          		{
   2752          			mtCOVERAGE_TEST_MARKER();
   2753          		}
   2754          	}
   2755          	#endif /* configUSE_PREEMPTION */
   2756          
   2757          	return xSwitchRequired;
   2758          }
   2759          /*-----------------------------------------------------------*/
   2760          
   2761          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2762          
   2763          	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
   2764          	{
   2765          	TCB_t *xTCB;
   2766          
   2767          		/* If xTask is NULL then it is the task hook of the calling task that is
   2768          		getting set. */
   2769          		if( xTask == NULL )
   2770          		{
   2771          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2772          		}
   2773          		else
   2774          		{
   2775          			xTCB = ( TCB_t * ) xTask;
   2776          		}
   2777          
   2778          		/* Save the hook function in the TCB.  A critical section is required as
   2779          		the value can be accessed from an interrupt. */
   2780          		taskENTER_CRITICAL();
   2781          			xTCB->pxTaskTag = pxHookFunction;
   2782          		taskEXIT_CRITICAL();
   2783          	}
   2784          
   2785          #endif /* configUSE_APPLICATION_TASK_TAG */
   2786          /*-----------------------------------------------------------*/
   2787          
   2788          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2789          
   2790          	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
   2791          	{
   2792          	TCB_t *xTCB;
   2793          	TaskHookFunction_t xReturn;
   2794          
   2795          		/* If xTask is NULL then we are setting our own task hook. */
   2796          		if( xTask == NULL )
   2797          		{
   2798          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2799          		}
   2800          		else
   2801          		{
   2802          			xTCB = ( TCB_t * ) xTask;
   2803          		}
   2804          
   2805          		/* Save the hook function in the TCB.  A critical section is required as
   2806          		the value can be accessed from an interrupt. */
   2807          		taskENTER_CRITICAL();
   2808          		{
   2809          			xReturn = xTCB->pxTaskTag;
   2810          		}
   2811          		taskEXIT_CRITICAL();
   2812          
   2813          		return xReturn;
   2814          	}
   2815          
   2816          #endif /* configUSE_APPLICATION_TASK_TAG */
   2817          /*-----------------------------------------------------------*/
   2818          
   2819          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2820          
   2821          	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
   2822          	{
   2823          	TCB_t *xTCB;
   2824          	BaseType_t xReturn;
   2825          
   2826          		/* If xTask is NULL then we are calling our own task hook. */
   2827          		if( xTask == NULL )
   2828          		{
   2829          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2830          		}
   2831          		else
   2832          		{
   2833          			xTCB = ( TCB_t * ) xTask;
   2834          		}
   2835          
   2836          		if( xTCB->pxTaskTag != NULL )
   2837          		{
   2838          			xReturn = xTCB->pxTaskTag( pvParameter );
   2839          		}
   2840          		else
   2841          		{
   2842          			xReturn = pdFAIL;
   2843          		}
   2844          
   2845          		return xReturn;
   2846          	}
   2847          
   2848          #endif /* configUSE_APPLICATION_TASK_TAG */
   2849          /*-----------------------------------------------------------*/
   2850          
   2851          void vTaskSwitchContext( void )
   2852          {
   2853          	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   2854          	{
   2855          		/* The scheduler is currently suspended - do not allow a context
   2856          		switch. */
   2857          		xYieldPending = pdTRUE;
   2858          	}
   2859          	else
   2860          	{
   2861          		xYieldPending = pdFALSE;
   2862          		traceTASK_SWITCHED_OUT();
   2863          
   2864          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2865          		{
   2866          				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   2867          					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
   2868          				#else
   2869          					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   2870          				#endif
   2871          
   2872          				/* Add the amount of time the task has been running to the
   2873          				accumulated time so far.  The time the task started running was
   2874          				stored in ulTaskSwitchedInTime.  Note that there is no overflow
   2875          				protection here so count values are only valid until the timer
   2876          				overflows.  The guard against negative values is to protect
   2877          				against suspect run time stat counter implementations - which
   2878          				are provided by the application, not the kernel. */
   2879          				if( ulTotalRunTime > ulTaskSwitchedInTime )
   2880          				{
   2881          					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   2882          				}
   2883          				else
   2884          				{
   2885          					mtCOVERAGE_TEST_MARKER();
   2886          				}
   2887          				ulTaskSwitchedInTime = ulTotalRunTime;
   2888          		}
   2889          		#endif /* configGENERATE_RUN_TIME_STATS */
   2890          
   2891          		/* Check for stack overflow, if configured. */
   2892          		taskCHECK_FOR_STACK_OVERFLOW();
   2893          
   2894          		/* Select a new task to run using either the generic C or port
   2895          		optimised asm code. */
   2896          		taskSELECT_HIGHEST_PRIORITY_TASK();
   2897          		traceTASK_SWITCHED_IN();
   2898          
   2899          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2900          		{
   2901          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   2902          			structure specific to this task. */
   2903          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   2904          		}
   2905          		#endif /* configUSE_NEWLIB_REENTRANT */
   2906          	}
   2907          }
   2908          /*-----------------------------------------------------------*/
   2909          
   2910          void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
   2911          {
   2912          	configASSERT( pxEventList );
   2913          
   2914          	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
   2915          	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
   2916          
   2917          	/* Place the event list item of the TCB in the appropriate event list.
   2918          	This is placed in the list in priority order so the highest priority task
   2919          	is the first to be woken by the event.  The queue that contains the event
   2920          	list is locked, preventing simultaneous access from interrupts. */
   2921          	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2922          
   2923          	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   2924          }
   2925          /*-----------------------------------------------------------*/
   2926          
   2927          void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
   2928          {
   2929          	configASSERT( pxEventList );
   2930          
   2931          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   2932          	the event groups implementation. */
   2933          	configASSERT( uxSchedulerSuspended != 0 );
   2934          
   2935          	/* Store the item value in the event list item.  It is safe to access the
   2936          	event list item here as interrupts won't access the event list item of a
   2937          	task that is not in the Blocked state. */
   2938          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   2939          
   2940          	/* Place the event list item of the TCB at the end of the appropriate event
   2941          	list.  It is safe to access the event list here because it is part of an
   2942          	event group implementation - and interrupts don't access event groups
   2943          	directly (instead they access them indirectly by pending function calls to
   2944          	the task level). */
   2945          	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2946          
   2947          	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   2948          }
   2949          /*-----------------------------------------------------------*/
   2950          
   2951          #if( configUSE_TIMERS == 1 )
   2952          
   2953          	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
   2954          	{
   2955          		configASSERT( pxEventList );
   2956          
   2957          		/* This function should not be called by application code hence the
   2958          		'Restricted' in its name.  It is not part of the public API.  It is
   2959          		designed for use by kernel code, and has special calling requirements -
   2960          		it should be called with the scheduler suspended. */
   2961          
   2962          
   2963          		/* Place the event list item of the TCB in the appropriate event list.
   2964          		In this case it is assume that this is the only task that is going to
   2965          		be waiting on this event list, so the faster vListInsertEnd() function
   2966          		can be used in place of vListInsert. */
   2967          		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2968          
   2969          		/* If the task should block indefinitely then set the block time to a
   2970          		value that will be recognised as an indefinite delay inside the
   2971          		prvAddCurrentTaskToDelayedList() function. */
   2972          		if( xWaitIndefinitely != pdFALSE )
   2973          		{
   2974          			xTicksToWait = portMAX_DELAY;
   2975          		}
   2976          
   2977          		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
   2978          		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
   2979          	}
   2980          
   2981          #endif /* configUSE_TIMERS */
   2982          /*-----------------------------------------------------------*/
   2983          
   2984          BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
   2985          {
   2986          TCB_t *pxUnblockedTCB;
   2987          BaseType_t xReturn;
   2988          
   2989          	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
   2990          	called from a critical section within an ISR. */
   2991          
   2992          	/* The event list is sorted in priority order, so the first in the list can
   2993          	be removed as it is known to be the highest priority.  Remove the TCB from
   2994          	the delayed list, and add it to the ready list.
   2995          
   2996          	If an event is for a queue that is locked then this function will never
   2997          	get called - the lock count on the queue will get modified instead.  This
   2998          	means exclusive access to the event list is guaranteed here.
   2999          
   3000          	This function assumes that a check has already been made to ensure that
   3001          	pxEventList is not empty. */
   3002          	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   3003          	configASSERT( pxUnblockedTCB );
   3004          	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   3005          
   3006          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   3007          	{
   3008          		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   3009          		prvAddTaskToReadyList( pxUnblockedTCB );
   3010          	}
   3011          	else
   3012          	{
   3013          		/* The delayed and ready lists cannot be accessed, so hold this task
   3014          		pending until the scheduler is resumed. */
   3015          		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   3016          	}
   3017          
   3018          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   3019          	{
   3020          		/* Return true if the task removed from the event list has a higher
   3021          		priority than the calling task.  This allows the calling task to know if
   3022          		it should force a context switch now. */
   3023          		xReturn = pdTRUE;
   3024          
   3025          		/* Mark that a yield is pending in case the user is not using the
   3026          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   3027          		xYieldPending = pdTRUE;
   3028          	}
   3029          	else
   3030          	{
   3031          		xReturn = pdFALSE;
   3032          	}
   3033          
   3034          	#if( configUSE_TICKLESS_IDLE != 0 )
   3035          	{
   3036          		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
   3037          		might be set to the blocked task's time out time.  If the task is
   3038          		unblocked for a reason other than a timeout xNextTaskUnblockTime is
   3039          		normally left unchanged, because it is automatically reset to a new
   3040          		value when the tick count equals xNextTaskUnblockTime.  However if
   3041          		tickless idling is used it might be more important to enter sleep mode
   3042          		at the earliest possible time - so reset xNextTaskUnblockTime here to
   3043          		ensure it is updated at the earliest possible time. */
   3044          		prvResetNextTaskUnblockTime();
   3045          	}
   3046          	#endif
   3047          
   3048          	return xReturn;
   3049          }
   3050          /*-----------------------------------------------------------*/
   3051          
   3052          void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
   3053          {
   3054          TCB_t *pxUnblockedTCB;
   3055          
   3056          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   3057          	the event flags implementation. */
   3058          	configASSERT( uxSchedulerSuspended != pdFALSE );
   3059          
   3060          	/* Store the new item value in the event list. */
   3061          	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   3062          
   3063          	/* Remove the event list form the event flag.  Interrupts do not access
   3064          	event flags. */
   3065          	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
   3066          	configASSERT( pxUnblockedTCB );
   3067          	( void ) uxListRemove( pxEventListItem );
   3068          
   3069          	/* Remove the task from the delayed list and add it to the ready list.  The
   3070          	scheduler is suspended so interrupts will not be accessing the ready
   3071          	lists. */
   3072          	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   3073          	prvAddTaskToReadyList( pxUnblockedTCB );
   3074          
   3075          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   3076          	{
   3077          		/* The unblocked task has a priority above that of the calling task, so
   3078          		a context switch is required.  This function is called with the
   3079          		scheduler suspended so xYieldPending is set so the context switch
   3080          		occurs immediately that the scheduler is resumed (unsuspended). */
   3081          		xYieldPending = pdTRUE;
   3082          	}
   3083          }
   3084          /*-----------------------------------------------------------*/
   3085          
   3086          void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
   3087          {
   3088          	configASSERT( pxTimeOut );
   3089          	taskENTER_CRITICAL();
   3090          	{
   3091          		pxTimeOut->xOverflowCount = xNumOfOverflows;
   3092          		pxTimeOut->xTimeOnEntering = xTickCount;
   3093          	}
   3094          	taskEXIT_CRITICAL();
   3095          }
   3096          /*-----------------------------------------------------------*/
   3097          
   3098          void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
   3099          {
   3100          	/* For internal use only as it does not use a critical section. */
   3101          	pxTimeOut->xOverflowCount = xNumOfOverflows;
   3102          	pxTimeOut->xTimeOnEntering = xTickCount;
   3103          }
   3104          /*-----------------------------------------------------------*/
   3105          
   3106          BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
   3107          {
   3108          BaseType_t xReturn;
   3109          
   3110          	configASSERT( pxTimeOut );
   3111          	configASSERT( pxTicksToWait );
   3112          
   3113          	taskENTER_CRITICAL();
   3114          	{
   3115          		/* Minor optimisation.  The tick count cannot change in this block. */
   3116          		const TickType_t xConstTickCount = xTickCount;
   3117          		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   3118          
   3119          		#if( INCLUDE_xTaskAbortDelay == 1 )
   3120          			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
   3121          			{
   3122          				/* The delay was aborted, which is not the same as a time out,
   3123          				but has the same result. */
   3124          				pxCurrentTCB->ucDelayAborted = pdFALSE;
   3125          				xReturn = pdTRUE;
   3126          			}
   3127          			else
   3128          		#endif
   3129          
   3130          		#if ( INCLUDE_vTaskSuspend == 1 )
   3131          			if( *pxTicksToWait == portMAX_DELAY )
   3132          			{
   3133          				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
   3134          				specified is the maximum block time then the task should block
   3135          				indefinitely, and therefore never time out. */
   3136          				xReturn = pdFALSE;
   3137          			}
   3138          			else
   3139          		#endif
   3140          
   3141          		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   3142          		{
   3143          			/* The tick count is greater than the time at which
   3144          			vTaskSetTimeout() was called, but has also overflowed since
   3145          			vTaskSetTimeOut() was called.  It must have wrapped all the way
   3146          			around and gone past again. This passed since vTaskSetTimeout()
   3147          			was called. */
   3148          			xReturn = pdTRUE;
   3149          		}
   3150          		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   3151          		{
   3152          			/* Not a genuine timeout. Adjust parameters for time remaining. */
   3153          			*pxTicksToWait -= xElapsedTime;
   3154          			vTaskInternalSetTimeOutState( pxTimeOut );
   3155          			xReturn = pdFALSE;
   3156          		}
   3157          		else
   3158          		{
   3159          			*pxTicksToWait = 0;
   3160          			xReturn = pdTRUE;
   3161          		}
   3162          	}
   3163          	taskEXIT_CRITICAL();
   3164          
   3165          	return xReturn;
   3166          }
   3167          /*-----------------------------------------------------------*/
   3168          
   3169          void vTaskMissedYield( void )
   3170          {
   3171          	xYieldPending = pdTRUE;
   3172          }
   3173          /*-----------------------------------------------------------*/
   3174          
   3175          #if ( configUSE_TRACE_FACILITY == 1 )
   3176          
   3177          	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
   3178          	{
   3179          	UBaseType_t uxReturn;
   3180          	TCB_t *pxTCB;
   3181          
   3182          		if( xTask != NULL )
   3183          		{
   3184          			pxTCB = ( TCB_t * ) xTask;
   3185          			uxReturn = pxTCB->uxTaskNumber;
   3186          		}
   3187          		else
   3188          		{
   3189          			uxReturn = 0U;
   3190          		}
   3191          
   3192          		return uxReturn;
   3193          	}
   3194          
   3195          #endif /* configUSE_TRACE_FACILITY */
   3196          /*-----------------------------------------------------------*/
   3197          
   3198          #if ( configUSE_TRACE_FACILITY == 1 )
   3199          
   3200          	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
   3201          	{
   3202          	TCB_t *pxTCB;
   3203          
   3204          		if( xTask != NULL )
   3205          		{
   3206          			pxTCB = ( TCB_t * ) xTask;
   3207          			pxTCB->uxTaskNumber = uxHandle;
   3208          		}
   3209          	}
   3210          
   3211          #endif /* configUSE_TRACE_FACILITY */
   3212          
   3213          /*
   3214           * -----------------------------------------------------------
   3215           * The Idle task.
   3216           * ----------------------------------------------------------
   3217           *
   3218           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
   3219           * language extensions.  The equivalent prototype for this function is:
   3220           *
   3221           * void prvIdleTask( void *pvParameters );
   3222           *
   3223           */
   3224          static portTASK_FUNCTION( prvIdleTask, pvParameters )
   3225          {
   3226          	/* Stop warnings. */
   3227          	( void ) pvParameters;
   3228          
   3229          	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
   3230          	SCHEDULER IS STARTED. **/
   3231          
   3232          	/* In case a task that has a secure context deletes itself, in which case
   3233          	the idle task is responsible for deleting the task's secure context, if
   3234          	any. */
   3235          	portTASK_CALLS_SECURE_FUNCTIONS();
   3236          
   3237          	for( ;; )
   3238          	{
   3239          		/* See if any tasks have deleted themselves - if so then the idle task
   3240          		is responsible for freeing the deleted task's TCB and stack. */
   3241          		prvCheckTasksWaitingTermination();
   3242          
   3243          		#if ( configUSE_PREEMPTION == 0 )
   3244          		{
   3245          			/* If we are not using preemption we keep forcing a task switch to
   3246          			see if any other task has become available.  If we are using
   3247          			preemption we don't need to do this as any task becoming available
   3248          			will automatically get the processor anyway. */
   3249          			taskYIELD();
   3250          		}
   3251          		#endif /* configUSE_PREEMPTION */
   3252          
   3253          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
   3254          		{
   3255          			/* When using preemption tasks of equal priority will be
   3256          			timesliced.  If a task that is sharing the idle priority is ready
   3257          			to run then the idle task should yield before the end of the
   3258          			timeslice.
   3259          
   3260          			A critical region is not required here as we are just reading from
   3261          			the list, and an occasional incorrect value will not matter.  If
   3262          			the ready list at the idle priority contains more than one task
   3263          			then a task other than the idle task is ready to execute. */
   3264          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   3265          			{
   3266          				taskYIELD();
   3267          			}
   3268          			else
   3269          			{
   3270          				mtCOVERAGE_TEST_MARKER();
   3271          			}
   3272          		}
   3273          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
   3274          
   3275          		#if ( configUSE_IDLE_HOOK == 1 )
   3276          		{
   3277          			extern void vApplicationIdleHook( void );
   3278          
   3279          			/* Call the user defined function from within the idle task.  This
   3280          			allows the application designer to add background functionality
   3281          			without the overhead of a separate task.
   3282          			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
   3283          			CALL A FUNCTION THAT MIGHT BLOCK. */
   3284          			vApplicationIdleHook();
   3285          		}
   3286          		#endif /* configUSE_IDLE_HOOK */
   3287          
   3288          		/* This conditional compilation should use inequality to 0, not equality
   3289          		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
   3290          		user defined low power mode	implementations require
   3291          		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
   3292          		#if ( configUSE_TICKLESS_IDLE != 0 )
   3293          		{
   3294          		TickType_t xExpectedIdleTime;
   3295          
   3296          			/* It is not desirable to suspend then resume the scheduler on
   3297          			each iteration of the idle task.  Therefore, a preliminary
   3298          			test of the expected idle time is performed without the
   3299          			scheduler suspended.  The result here is not necessarily
   3300          			valid. */
   3301          			xExpectedIdleTime = prvGetExpectedIdleTime();
   3302          
   3303          			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   3304          			{
   3305          				vTaskSuspendAll();
   3306          				{
   3307          					/* Now the scheduler is suspended, the expected idle
   3308          					time can be sampled again, and this time its value can
   3309          					be used. */
   3310          					configASSERT( xNextTaskUnblockTime >= xTickCount );
   3311          					xExpectedIdleTime = prvGetExpectedIdleTime();
   3312          
   3313          					/* Define the following macro to set xExpectedIdleTime to 0
   3314          					if the application does not want
   3315          					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
   3316          					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
   3317          
   3318          					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   3319          					{
   3320          						traceLOW_POWER_IDLE_BEGIN();
   3321          						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
   3322          						traceLOW_POWER_IDLE_END();
   3323          					}
   3324          					else
   3325          					{
   3326          						mtCOVERAGE_TEST_MARKER();
   3327          					}
   3328          				}
   3329          				( void ) xTaskResumeAll();
   3330          			}
   3331          			else
   3332          			{
   3333          				mtCOVERAGE_TEST_MARKER();
   3334          			}
   3335          		}
   3336          		#endif /* configUSE_TICKLESS_IDLE */
   3337          	}
   3338          }
   3339          /*-----------------------------------------------------------*/
   3340          
   3341          #if( configUSE_TICKLESS_IDLE != 0 )
   3342          
   3343          	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
   3344          	{
   3345          	/* The idle task exists in addition to the application tasks. */
   3346          	const UBaseType_t uxNonApplicationTasks = 1;
   3347          	eSleepModeStatus eReturn = eStandardSleep;
   3348          
   3349          		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
   3350          		{
   3351          			/* A task was made ready while the scheduler was suspended. */
   3352          			eReturn = eAbortSleep;
   3353          		}
   3354          		else if( xYieldPending != pdFALSE )
   3355          		{
   3356          			/* A yield was pended while the scheduler was suspended. */
   3357          			eReturn = eAbortSleep;
   3358          		}
   3359          		else
   3360          		{
   3361          			/* If all the tasks are in the suspended list (which might mean they
   3362          			have an infinite block time rather than actually being suspended)
   3363          			then it is safe to turn all clocks off and just wait for external
   3364          			interrupts. */
   3365          			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
   3366          			{
   3367          				eReturn = eNoTasksWaitingTimeout;
   3368          			}
   3369          			else
   3370          			{
   3371          				mtCOVERAGE_TEST_MARKER();
   3372          			}
   3373          		}
   3374          
   3375          		return eReturn;
   3376          	}
   3377          
   3378          #endif /* configUSE_TICKLESS_IDLE */
   3379          /*-----------------------------------------------------------*/
   3380          
   3381          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   3382          
   3383          	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
   3384          	{
   3385          	TCB_t *pxTCB;
   3386          
   3387          		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
   3388          		{
   3389          			pxTCB = prvGetTCBFromHandle( xTaskToSet );
   3390          			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
   3391          		}
   3392          	}
   3393          
   3394          #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
   3395          /*-----------------------------------------------------------*/
   3396          
   3397          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   3398          
   3399          	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
   3400          	{
   3401          	void *pvReturn = NULL;
   3402          	TCB_t *pxTCB;
   3403          
   3404          		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
   3405          		{
   3406          			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   3407          			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
   3408          		}
   3409          		else
   3410          		{
   3411          			pvReturn = NULL;
   3412          		}
   3413          
   3414          		return pvReturn;
   3415          	}
   3416          
   3417          #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
   3418          /*-----------------------------------------------------------*/
   3419          
   3420          #if ( portUSING_MPU_WRAPPERS == 1 )
   3421          
   3422          	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
   3423          	{
   3424          	TCB_t *pxTCB;
   3425          
   3426          		/* If null is passed in here then we are modifying the MPU settings of
   3427          		the calling task. */
   3428          		pxTCB = prvGetTCBFromHandle( xTaskToModify );
   3429          
   3430          		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
   3431          	}
   3432          
   3433          #endif /* portUSING_MPU_WRAPPERS */
   3434          /*-----------------------------------------------------------*/
   3435          
   3436          static void prvInitialiseTaskLists( void )
   3437          {
   3438          UBaseType_t uxPriority;
   3439          
   3440          	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   3441          	{
   3442          		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   3443          	}
   3444          
   3445          	vListInitialise( &xDelayedTaskList1 );
   3446          	vListInitialise( &xDelayedTaskList2 );
   3447          	vListInitialise( &xPendingReadyList );
   3448          
   3449          	#if ( INCLUDE_vTaskDelete == 1 )
   3450          	{
   3451          		vListInitialise( &xTasksWaitingTermination );
   3452          	}
   3453          	#endif /* INCLUDE_vTaskDelete */
   3454          
   3455          	#if ( INCLUDE_vTaskSuspend == 1 )
   3456          	{
   3457          		vListInitialise( &xSuspendedTaskList );
   3458          	}
   3459          	#endif /* INCLUDE_vTaskSuspend */
   3460          
   3461          	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
   3462          	using list2. */
   3463          	pxDelayedTaskList = &xDelayedTaskList1;
   3464          	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   3465          }
   3466          /*-----------------------------------------------------------*/
   3467          
   3468          static void prvCheckTasksWaitingTermination( void )
   3469          {
   3470          
   3471          	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
   3472          
   3473          	#if ( INCLUDE_vTaskDelete == 1 )
   3474          	{
   3475          		TCB_t *pxTCB;
   3476          
   3477          		/* uxDeletedTasksWaitingCleanUp is used to prevent vTaskSuspendAll()
   3478          		being called too often in the idle task. */
   3479          		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   3480          		{
   3481          			taskENTER_CRITICAL();
   3482          			{
   3483          				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   3484          				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   3485          				--uxCurrentNumberOfTasks;
   3486          				--uxDeletedTasksWaitingCleanUp;
   3487          			}
   3488          			taskEXIT_CRITICAL();
   3489          
   3490          			prvDeleteTCB( pxTCB );
   3491          		}
   3492          	}
   3493          	#endif /* INCLUDE_vTaskDelete */
   3494          }
   3495          /*-----------------------------------------------------------*/
   3496          
   3497          #if( configUSE_TRACE_FACILITY == 1 )
   3498          
   3499          	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
   3500          	{
   3501          	TCB_t *pxTCB;
   3502          
   3503          		/* xTask is NULL then get the state of the calling task. */
   3504          		pxTCB = prvGetTCBFromHandle( xTask );
   3505          
   3506          		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
   3507          		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
   3508          		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
   3509          		pxTaskStatus->pxStackBase = pxTCB->pxStack;
   3510          		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
   3511          
   3512          		#if ( configUSE_MUTEXES == 1 )
   3513          		{
   3514          			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
   3515          		}
   3516          		#else
   3517          		{
   3518          			pxTaskStatus->uxBasePriority = 0;
   3519          		}
   3520          		#endif
   3521          
   3522          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   3523          		{
   3524          			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
   3525          		}
   3526          		#else
   3527          		{
   3528          			pxTaskStatus->ulRunTimeCounter = 0;
   3529          		}
   3530          		#endif
   3531          
   3532          		/* Obtaining the task state is a little fiddly, so is only done if the
   3533          		value of eState passed into this function is eInvalid - otherwise the
   3534          		state is just set to whatever is passed in. */
   3535          		if( eState != eInvalid )
   3536          		{
   3537          			if( pxTCB == pxCurrentTCB )
   3538          			{
   3539          				pxTaskStatus->eCurrentState = eRunning;
   3540          			}
   3541          			else
   3542          			{
   3543          				pxTaskStatus->eCurrentState = eState;
   3544          
   3545          				#if ( INCLUDE_vTaskSuspend == 1 )
   3546          				{
   3547          					/* If the task is in the suspended list then there is a
   3548          					chance it is actually just blocked indefinitely - so really
   3549          					it should be reported as being in the Blocked state. */
   3550          					if( eState == eSuspended )
   3551          					{
   3552          						vTaskSuspendAll();
   3553          						{
   3554          							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   3555          							{
   3556          								pxTaskStatus->eCurrentState = eBlocked;
   3557          							}
   3558          						}
   3559          						( void ) xTaskResumeAll();
   3560          					}
   3561          				}
   3562          				#endif /* INCLUDE_vTaskSuspend */
   3563          			}
   3564          		}
   3565          		else
   3566          		{
   3567          			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
   3568          		}
   3569          
   3570          		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
   3571          		parameter is provided to allow it to be skipped. */
   3572          		if( xGetFreeStackSpace != pdFALSE )
   3573          		{
   3574          			#if ( portSTACK_GROWTH > 0 )
   3575          			{
   3576          				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
   3577          			}
   3578          			#else
   3579          			{
   3580          				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
   3581          			}
   3582          			#endif
   3583          		}
   3584          		else
   3585          		{
   3586          			pxTaskStatus->usStackHighWaterMark = 0;
   3587          		}
   3588          	}
   3589          
   3590          #endif /* configUSE_TRACE_FACILITY */
   3591          /*-----------------------------------------------------------*/
   3592          
   3593          #if ( configUSE_TRACE_FACILITY == 1 )
   3594          
   3595          	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
   3596          	{
   3597          	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
   3598          	UBaseType_t uxTask = 0;
   3599          
   3600          		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   3601          		{
   3602          			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   3603          
   3604          			/* Populate an TaskStatus_t structure within the
   3605          			pxTaskStatusArray array for each task that is referenced from
   3606          			pxList.  See the definition of TaskStatus_t in task.h for the
   3607          			meaning of each TaskStatus_t structure member. */
   3608          			do
   3609          			{
   3610          				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   3611          				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
   3612          				uxTask++;
   3613          			} while( pxNextTCB != pxFirstTCB );
   3614          		}
   3615          		else
   3616          		{
   3617          			mtCOVERAGE_TEST_MARKER();
   3618          		}
   3619          
   3620          		return uxTask;
   3621          	}
   3622          
   3623          #endif /* configUSE_TRACE_FACILITY */
   3624          /*-----------------------------------------------------------*/
   3625          
   3626          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   3627          
   3628          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
   3629          	{
   3630          	uint32_t ulCount = 0U;
   3631          
   3632          		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   3633          		{
   3634          			pucStackByte -= portSTACK_GROWTH;
   3635          			ulCount++;
   3636          		}
   3637          
   3638          		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
   3639          
   3640          		return ( uint16_t ) ulCount;
   3641          	}
   3642          
   3643          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
   3644          /*-----------------------------------------------------------*/
   3645          
   3646          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
   3647          
   3648          	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
   3649          	{
   3650          	TCB_t *pxTCB;
   3651          	uint8_t *pucEndOfStack;
   3652          	UBaseType_t uxReturn;
   3653          
   3654          		pxTCB = prvGetTCBFromHandle( xTask );
   3655          
   3656          		#if portSTACK_GROWTH < 0
   3657          		{
   3658          			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
   3659          		}
   3660          		#else
   3661          		{
   3662          			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
   3663          		}
   3664          		#endif
   3665          
   3666          		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
   3667          
   3668          		return uxReturn;
   3669          	}
   3670          
   3671          #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
   3672          /*-----------------------------------------------------------*/
   3673          
   3674          #if ( INCLUDE_vTaskDelete == 1 )
   3675          
   3676          	static void prvDeleteTCB( TCB_t *pxTCB )
   3677          	{
   3678          		/* This call is required specifically for the TriCore port.  It must be
   3679          		above the vPortFree() calls.  The call is also used by ports/demos that
   3680          		want to allocate and clean RAM statically. */
   3681          		portCLEAN_UP_TCB( pxTCB );
   3682          
   3683          		/* Free up the memory allocated by the scheduler for the task.  It is up
   3684          		to the task to free any memory allocated at the application level. */
   3685          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   3686          		{
   3687          			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
   3688          		}
   3689          		#endif /* configUSE_NEWLIB_REENTRANT */
   3690          
   3691          		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
   3692          		{
   3693          			/* The task can only have been allocated dynamically - free both
   3694          			the stack and TCB. */
   3695          			vPortFree( pxTCB->pxStack );
   3696          			vPortFree( pxTCB );
   3697          		}
   3698          		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
   3699          		{
   3700          			/* The task could have been allocated statically or dynamically, so
   3701          			check what was statically allocated before trying to free the
   3702          			memory. */
   3703          			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
   3704          			{
   3705          				/* Both the stack and TCB were allocated dynamically, so both
   3706          				must be freed. */
   3707          				vPortFree( pxTCB->pxStack );
   3708          				vPortFree( pxTCB );
   3709          			}
   3710          			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
   3711          			{
   3712          				/* Only the stack was statically allocated, so the TCB is the
   3713          				only memory that must be freed. */
   3714          				vPortFree( pxTCB );
   3715          			}
   3716          			else
   3717          			{
   3718          				/* Neither the stack nor the TCB were allocated dynamically, so
   3719          				nothing needs to be freed. */
   3720          				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
   3721          				mtCOVERAGE_TEST_MARKER();
   3722          			}
   3723          		}
   3724          		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
   3725          	}
   3726          
   3727          #endif /* INCLUDE_vTaskDelete */
   3728          /*-----------------------------------------------------------*/
   3729          
   3730          static void prvResetNextTaskUnblockTime( void )
   3731          {
   3732          TCB_t *pxTCB;
   3733          
   3734          	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   3735          	{
   3736          		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
   3737          		the maximum possible value so it is	extremely unlikely that the
   3738          		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
   3739          		there is an item in the delayed list. */
   3740          		xNextTaskUnblockTime = portMAX_DELAY;
   3741          	}
   3742          	else
   3743          	{
   3744          		/* The new current delayed list is not empty, get the value of
   3745          		the item at the head of the delayed list.  This is the time at
   3746          		which the task at the head of the delayed list should be removed
   3747          		from the Blocked state. */
   3748          		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   3749          		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   3750          	}
   3751          }
   3752          /*-----------------------------------------------------------*/
   3753          
   3754          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
   3755          
   3756          	TaskHandle_t xTaskGetCurrentTaskHandle( void )
   3757          	{
   3758          	TaskHandle_t xReturn;
   3759          
   3760          		/* A critical section is not required as this is not called from
   3761          		an interrupt and the current TCB will always be the same for any
   3762          		individual execution thread. */
   3763          		xReturn = pxCurrentTCB;
   3764          
   3765          		return xReturn;
   3766          	}
   3767          
   3768          #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
   3769          /*-----------------------------------------------------------*/
   3770          
   3771          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   3772          
   3773          	BaseType_t xTaskGetSchedulerState( void )
   3774          	{
   3775          	BaseType_t xReturn;
   3776          
   3777          		if( xSchedulerRunning == pdFALSE )
   3778          		{
   3779          			xReturn = taskSCHEDULER_NOT_STARTED;
   3780          		}
   3781          		else
   3782          		{
   3783          			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   3784          			{
   3785          				xReturn = taskSCHEDULER_RUNNING;
   3786          			}
   3787          			else
   3788          			{
   3789          				xReturn = taskSCHEDULER_SUSPENDED;
   3790          			}
   3791          		}
   3792          
   3793          		return xReturn;
   3794          	}
   3795          
   3796          #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
   3797          /*-----------------------------------------------------------*/
   3798          
   3799          #if ( configUSE_MUTEXES == 1 )
   3800          
   3801          	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
   3802          	{
   3803          	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
   3804          	BaseType_t xReturn = pdFALSE;
   3805          
   3806          		/* If the mutex was given back by an interrupt while the queue was
   3807          		locked then the mutex holder might now be NULL.  _RB_ Is this still
   3808          		needed as interrupts can no longer use mutexes? */
   3809          		if( pxMutexHolder != NULL )
   3810          		{
   3811          			/* If the holder of the mutex has a priority below the priority of
   3812          			the task attempting to obtain the mutex then it will temporarily
   3813          			inherit the priority of the task attempting to obtain the mutex. */
   3814          			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
   3815          			{
   3816          				/* Adjust the mutex holder state to account for its new
   3817          				priority.  Only reset the event list item value if the value is
   3818          				not being used for anything else. */
   3819          				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   3820          				{
   3821          					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3822          				}
   3823          				else
   3824          				{
   3825          					mtCOVERAGE_TEST_MARKER();
   3826          				}
   3827          
   3828          				/* If the task being modified is in the ready state it will need
   3829          				to be moved into a new list. */
   3830          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
   3831          				{
   3832          					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   3833          					{
   3834          						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
   3835          					}
   3836          					else
   3837          					{
   3838          						mtCOVERAGE_TEST_MARKER();
   3839          					}
   3840          
   3841          					/* Inherit the priority before being moved into the new list. */
   3842          					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   3843          					prvAddTaskToReadyList( pxMutexHolderTCB );
   3844          				}
   3845          				else
   3846          				{
   3847          					/* Just inherit the priority. */
   3848          					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   3849          				}
   3850          
   3851          				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
   3852          
   3853          				/* Inheritance occurred. */
   3854          				xReturn = pdTRUE;
   3855          			}
   3856          			else
   3857          			{
   3858          				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
   3859          				{
   3860          					/* The base priority of the mutex holder is lower than the
   3861          					priority of the task attempting to take the mutex, but the
   3862          					current priority of the mutex holder is not lower than the
   3863          					priority of the task attempting to take the mutex.
   3864          					Therefore the mutex holder must have already inherited a
   3865          					priority, but inheritance would have occurred if that had
   3866          					not been the case. */
   3867          					xReturn = pdTRUE;
   3868          				}
   3869          				else
   3870          				{
   3871          					mtCOVERAGE_TEST_MARKER();
   3872          				}
   3873          			}
   3874          		}
   3875          		else
   3876          		{
   3877          			mtCOVERAGE_TEST_MARKER();
   3878          		}
   3879          
   3880          		return xReturn;
   3881          	}
   3882          
   3883          #endif /* configUSE_MUTEXES */
   3884          /*-----------------------------------------------------------*/
   3885          
   3886          #if ( configUSE_MUTEXES == 1 )
   3887          
   3888          	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
   3889          	{
   3890          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3891          	BaseType_t xReturn = pdFALSE;
   3892          
   3893          		if( pxMutexHolder != NULL )
   3894          		{
   3895          			/* A task can only have an inherited priority if it holds the mutex.
   3896          			If the mutex is held by a task then it cannot be given from an
   3897          			interrupt, and if a mutex is given by the holding task then it must
   3898          			be the running state task. */
   3899          			configASSERT( pxTCB == pxCurrentTCB );
   3900          			configASSERT( pxTCB->uxMutexesHeld );
   3901          			( pxTCB->uxMutexesHeld )--;
   3902          
   3903          			/* Has the holder of the mutex inherited the priority of another
   3904          			task? */
   3905          			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   3906          			{
   3907          				/* Only disinherit if no other mutexes are held. */
   3908          				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   3909          				{
   3910          					/* A task can only have an inherited priority if it holds
   3911          					the mutex.  If the mutex is held by a task then it cannot be
   3912          					given from an interrupt, and if a mutex is given by the
   3913          					holding task then it must be the running state task.  Remove
   3914          					the holding task from the ready list. */
   3915          					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   3916          					{
   3917          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   3918          					}
   3919          					else
   3920          					{
   3921          						mtCOVERAGE_TEST_MARKER();
   3922          					}
   3923          
   3924          					/* Disinherit the priority before adding the task into the
   3925          					new	ready list. */
   3926          					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   3927          					pxTCB->uxPriority = pxTCB->uxBasePriority;
   3928          
   3929          					/* Reset the event list item value.  It cannot be in use for
   3930          					any other purpose if this task is running, and it must be
   3931          					running to give back the mutex. */
   3932          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3933          					prvAddTaskToReadyList( pxTCB );
   3934          
   3935          					/* Return true to indicate that a context switch is required.
   3936          					This is only actually required in the corner case whereby
   3937          					multiple mutexes were held and the mutexes were given back
   3938          					in an order different to that in which they were taken.
   3939          					If a context switch did not occur when the first mutex was
   3940          					returned, even if a task was waiting on it, then a context
   3941          					switch should occur when the last mutex is returned whether
   3942          					a task is waiting on it or not. */
   3943          					xReturn = pdTRUE;
   3944          				}
   3945          				else
   3946          				{
   3947          					mtCOVERAGE_TEST_MARKER();
   3948          				}
   3949          			}
   3950          			else
   3951          			{
   3952          				mtCOVERAGE_TEST_MARKER();
   3953          			}
   3954          		}
   3955          		else
   3956          		{
   3957          			mtCOVERAGE_TEST_MARKER();
   3958          		}
   3959          
   3960          		return xReturn;
   3961          	}
   3962          
   3963          #endif /* configUSE_MUTEXES */
   3964          /*-----------------------------------------------------------*/
   3965          
   3966          #if ( configUSE_MUTEXES == 1 )
   3967          
   3968          	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
   3969          	{
   3970          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3971          	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
   3972          	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
   3973          
   3974          		if( pxMutexHolder != NULL )
   3975          		{
   3976          			/* If pxMutexHolder is not NULL then the holder must hold at least
   3977          			one mutex. */
   3978          			configASSERT( pxTCB->uxMutexesHeld );
   3979          
   3980          			/* Determine the priority to which the priority of the task that
   3981          			holds the mutex should be set.  This will be the greater of the
   3982          			holding task's base priority and the priority of the highest
   3983          			priority task that is waiting to obtain the mutex. */
   3984          			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
   3985          			{
   3986          				uxPriorityToUse = uxHighestPriorityWaitingTask;
   3987          			}
   3988          			else
   3989          			{
   3990          				uxPriorityToUse = pxTCB->uxBasePriority;
   3991          			}
   3992          
   3993          			/* Does the priority need to change? */
   3994          			if( pxTCB->uxPriority != uxPriorityToUse )
   3995          			{
   3996          				/* Only disinherit if no other mutexes are held.  This is a
   3997          				simplification in the priority inheritance implementation.  If
   3998          				the task that holds the mutex is also holding other mutexes then
   3999          				the other mutexes may have caused the priority inheritance. */
   4000          				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
   4001          				{
   4002          					/* If a task has timed out because it already holds the
   4003          					mutex it was trying to obtain then it cannot of inherited
   4004          					its own priority. */
   4005          					configASSERT( pxTCB != pxCurrentTCB );
   4006          
   4007          					/* Disinherit the priority, remembering the previous
   4008          					priority to facilitate determining the subject task's
   4009          					state. */
   4010          					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   4011          					uxPriorityUsedOnEntry = pxTCB->uxPriority;
   4012          					pxTCB->uxPriority = uxPriorityToUse;
   4013          
   4014          					/* Only reset the event list item value if the value is not
   4015          					being used for anything else. */
   4016          					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   4017          					{
   4018          						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   4019          					}
   4020          					else
   4021          					{
   4022          						mtCOVERAGE_TEST_MARKER();
   4023          					}
   4024          
   4025          					/* If the running task is not the task that holds the mutex
   4026          					then the task that holds the mutex could be in either the
   4027          					Ready, Blocked or Suspended states.  Only remove the task
   4028          					from its current state list if it is in the Ready state as
   4029          					the task's priority is going to change and there is one
   4030          					Ready list per priority. */
   4031          					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   4032          					{
   4033          						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   4034          						{
   4035          							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   4036          						}
   4037          						else
   4038          						{
   4039          							mtCOVERAGE_TEST_MARKER();
   4040          						}
   4041          
   4042          						prvAddTaskToReadyList( pxTCB );
   4043          					}
   4044          					else
   4045          					{
   4046          						mtCOVERAGE_TEST_MARKER();
   4047          					}
   4048          				}
   4049          				else
   4050          				{
   4051          					mtCOVERAGE_TEST_MARKER();
   4052          				}
   4053          			}
   4054          			else
   4055          			{
   4056          				mtCOVERAGE_TEST_MARKER();
   4057          			}
   4058          		}
   4059          		else
   4060          		{
   4061          			mtCOVERAGE_TEST_MARKER();
   4062          		}
   4063          	}
   4064          
   4065          #endif /* configUSE_MUTEXES */
   4066          /*-----------------------------------------------------------*/
   4067          
   4068          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   4069          
   4070          	void vTaskEnterCritical( void )
   4071          	{
   4072          		portDISABLE_INTERRUPTS();
   4073          
   4074          		if( xSchedulerRunning != pdFALSE )
   4075          		{
   4076          			( pxCurrentTCB->uxCriticalNesting )++;
   4077          
   4078          			/* This is not the interrupt safe version of the enter critical
   4079          			function so	assert() if it is being called from an interrupt
   4080          			context.  Only API functions that end in "FromISR" can be used in an
   4081          			interrupt.  Only assert if the critical nesting count is 1 to
   4082          			protect against recursive calls if the assert function also uses a
   4083          			critical section. */
   4084          			if( pxCurrentTCB->uxCriticalNesting == 1 )
   4085          			{
   4086          				portASSERT_IF_IN_ISR();
   4087          			}
   4088          		}
   4089          		else
   4090          		{
   4091          			mtCOVERAGE_TEST_MARKER();
   4092          		}
   4093          	}
   4094          
   4095          #endif /* portCRITICAL_NESTING_IN_TCB */
   4096          /*-----------------------------------------------------------*/
   4097          
   4098          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   4099          
   4100          	void vTaskExitCritical( void )
   4101          	{
   4102          		if( xSchedulerRunning != pdFALSE )
   4103          		{
   4104          			if( pxCurrentTCB->uxCriticalNesting > 0U )
   4105          			{
   4106          				( pxCurrentTCB->uxCriticalNesting )--;
   4107          
   4108          				if( pxCurrentTCB->uxCriticalNesting == 0U )
   4109          				{
   4110          					portENABLE_INTERRUPTS();
   4111          				}
   4112          				else
   4113          				{
   4114          					mtCOVERAGE_TEST_MARKER();
   4115          				}
   4116          			}
   4117          			else
   4118          			{
   4119          				mtCOVERAGE_TEST_MARKER();
   4120          			}
   4121          		}
   4122          		else
   4123          		{
   4124          			mtCOVERAGE_TEST_MARKER();
   4125          		}
   4126          	}
   4127          
   4128          #endif /* portCRITICAL_NESTING_IN_TCB */
   4129          /*-----------------------------------------------------------*/
   4130          
   4131          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   4132          
   4133          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
   4134          	{
   4135          	size_t x;
   4136          
   4137          		/* Start by copying the entire string. */
   4138          		strcpy( pcBuffer, pcTaskName );
   4139          
   4140          		/* Pad the end of the string with spaces to ensure columns line up when
   4141          		printed out. */
   4142          		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   4143          		{
   4144          			pcBuffer[ x ] = ' ';
   4145          		}
   4146          
   4147          		/* Terminate. */
   4148          		pcBuffer[ x ] = 0x00;
   4149          
   4150          		/* Return the new end of string. */
   4151          		return &( pcBuffer[ x ] );
   4152          	}
   4153          
   4154          #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
   4155          /*-----------------------------------------------------------*/
   4156          
   4157          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
   4158          
   4159          	void vTaskList( char * pcWriteBuffer )
   4160          	{
   4161          	TaskStatus_t *pxTaskStatusArray;
   4162          	volatile UBaseType_t uxArraySize, x;
   4163          	char cStatus;
   4164          
   4165          		/*
   4166          		 * PLEASE NOTE:
   4167          		 *
   4168          		 * This function is provided for convenience only, and is used by many
   4169          		 * of the demo applications.  Do not consider it to be part of the
   4170          		 * scheduler.
   4171          		 *
   4172          		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
   4173          		 * uxTaskGetSystemState() output into a human readable table that
   4174          		 * displays task names, states and stack usage.
   4175          		 *
   4176          		 * vTaskList() has a dependency on the sprintf() C library function that
   4177          		 * might bloat the code size, use a lot of stack, and provide different
   4178          		 * results on different platforms.  An alternative, tiny, third party,
   4179          		 * and limited functionality implementation of sprintf() is provided in
   4180          		 * many of the FreeRTOS/Demo sub-directories in a file called
   4181          		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
   4182          		 * snprintf() implementation!).
   4183          		 *
   4184          		 * It is recommended that production systems call uxTaskGetSystemState()
   4185          		 * directly to get access to raw stats data, rather than indirectly
   4186          		 * through a call to vTaskList().
   4187          		 */
   4188          
   4189          
   4190          		/* Make sure the write buffer does not contain a string. */
   4191          		*pcWriteBuffer = 0x00;
   4192          
   4193          		/* Take a snapshot of the number of tasks in case it changes while this
   4194          		function is executing. */
   4195          		uxArraySize = uxCurrentNumberOfTasks;
   4196          
   4197          		/* Allocate an array index for each task.  NOTE!  if
   4198          		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
   4199          		equate to NULL. */
   4200          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   4201          
   4202          		if( pxTaskStatusArray != NULL )
   4203          		{
   4204          			/* Generate the (binary) data. */
   4205          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
   4206          
   4207          			/* Create a human readable table from the binary data. */
   4208          			for( x = 0; x < uxArraySize; x++ )
   4209          			{
   4210          				switch( pxTaskStatusArray[ x ].eCurrentState )
   4211          				{
   4212          					case eRunning:		cStatus = tskRUNNING_CHAR;
   4213          										break;
   4214          
   4215          					case eReady:		cStatus = tskREADY_CHAR;
   4216          										break;
   4217          
   4218          					case eBlocked:		cStatus = tskBLOCKED_CHAR;
   4219          										break;
   4220          
   4221          					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
   4222          										break;
   4223          
   4224          					case eDeleted:		cStatus = tskDELETED_CHAR;
   4225          										break;
   4226          
   4227          					default:			/* Should not get here, but it is included
   4228          										to prevent static checking errors. */
   4229          										cStatus = 0x00;
   4230          										break;
   4231          				}
   4232          
   4233          				/* Write the task name to the string, padding with spaces so it
   4234          				can be printed in tabular form more easily. */
   4235          				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   4236          
   4237          				/* Write the rest of the string. */
   4238          				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
   4239          				pcWriteBuffer += strlen( pcWriteBuffer );
   4240          			}
   4241          
   4242          			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
   4243          			is 0 then vPortFree() will be #defined to nothing. */
   4244          			vPortFree( pxTaskStatusArray );
   4245          		}
   4246          		else
   4247          		{
   4248          			mtCOVERAGE_TEST_MARKER();
   4249          		}
   4250          	}
   4251          
   4252          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
   4253          /*----------------------------------------------------------*/
   4254          
   4255          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
   4256          
   4257          	void vTaskGetRunTimeStats( char *pcWriteBuffer )
   4258          	{
   4259          	TaskStatus_t *pxTaskStatusArray;
   4260          	volatile UBaseType_t uxArraySize, x;
   4261          	uint32_t ulTotalTime, ulStatsAsPercentage;
   4262          
   4263          		#if( configUSE_TRACE_FACILITY != 1 )
   4264          		{
   4265          			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
   4266          		}
   4267          		#endif
   4268          
   4269          		/*
   4270          		 * PLEASE NOTE:
   4271          		 *
   4272          		 * This function is provided for convenience only, and is used by many
   4273          		 * of the demo applications.  Do not consider it to be part of the
   4274          		 * scheduler.
   4275          		 *
   4276          		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
   4277          		 * of the uxTaskGetSystemState() output into a human readable table that
   4278          		 * displays the amount of time each task has spent in the Running state
   4279          		 * in both absolute and percentage terms.
   4280          		 *
   4281          		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
   4282          		 * function that might bloat the code size, use a lot of stack, and
   4283          		 * provide different results on different platforms.  An alternative,
   4284          		 * tiny, third party, and limited functionality implementation of
   4285          		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
   4286          		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
   4287          		 * a full snprintf() implementation!).
   4288          		 *
   4289          		 * It is recommended that production systems call uxTaskGetSystemState()
   4290          		 * directly to get access to raw stats data, rather than indirectly
   4291          		 * through a call to vTaskGetRunTimeStats().
   4292          		 */
   4293          
   4294          		/* Make sure the write buffer does not contain a string. */
   4295          		*pcWriteBuffer = 0x00;
   4296          
   4297          		/* Take a snapshot of the number of tasks in case it changes while this
   4298          		function is executing. */
   4299          		uxArraySize = uxCurrentNumberOfTasks;
   4300          
   4301          		/* Allocate an array index for each task.  NOTE!  If
   4302          		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
   4303          		equate to NULL. */
   4304          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   4305          
   4306          		if( pxTaskStatusArray != NULL )
   4307          		{
   4308          			/* Generate the (binary) data. */
   4309          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
   4310          
   4311          			/* For percentage calculations. */
   4312          			ulTotalTime /= 100UL;
   4313          
   4314          			/* Avoid divide by zero errors. */
   4315          			if( ulTotalTime > 0 )
   4316          			{
   4317          				/* Create a human readable table from the binary data. */
   4318          				for( x = 0; x < uxArraySize; x++ )
   4319          				{
   4320          					/* What percentage of the total run time has the task used?
   4321          					This will always be rounded down to the nearest integer.
   4322          					ulTotalRunTimeDiv100 has already been divided by 100. */
   4323          					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
   4324          
   4325          					/* Write the task name to the string, padding with
   4326          					spaces so it can be printed in tabular form more
   4327          					easily. */
   4328          					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   4329          
   4330          					if( ulStatsAsPercentage > 0UL )
   4331          					{
   4332          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   4333          						{
   4334          							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
   4335          						}
   4336          						#else
   4337          						{
   4338          							/* sizeof( int ) == sizeof( long ) so a smaller
   4339          							printf() library can be used. */
   4340          							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
   4341          						}
   4342          						#endif
   4343          					}
   4344          					else
   4345          					{
   4346          						/* If the percentage is zero here then the task has
   4347          						consumed less than 1% of the total run time. */
   4348          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   4349          						{
   4350          							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
   4351          						}
   4352          						#else
   4353          						{
   4354          							/* sizeof( int ) == sizeof( long ) so a smaller
   4355          							printf() library can be used. */
   4356          							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
   4357          						}
   4358          						#endif
   4359          					}
   4360          
   4361          					pcWriteBuffer += strlen( pcWriteBuffer );
   4362          				}
   4363          			}
   4364          			else
   4365          			{
   4366          				mtCOVERAGE_TEST_MARKER();
   4367          			}
   4368          
   4369          			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
   4370          			is 0 then vPortFree() will be #defined to nothing. */
   4371          			vPortFree( pxTaskStatusArray );
   4372          		}
   4373          		else
   4374          		{
   4375          			mtCOVERAGE_TEST_MARKER();
   4376          		}
   4377          	}
   4378          
   4379          #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
   4380          /*-----------------------------------------------------------*/
   4381          
   4382          TickType_t uxTaskResetEventItemValue( void )
   4383          {
   4384          TickType_t uxReturn;
   4385          
   4386          	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   4387          
   4388          	/* Reset the event list item to its normal value - so it can be used with
   4389          	queues and semaphores. */
   4390          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   4391          
   4392          	return uxReturn;
   4393          }
   4394          /*-----------------------------------------------------------*/
   4395          
   4396          #if ( configUSE_MUTEXES == 1 )
   4397          
   4398          	void *pvTaskIncrementMutexHeldCount( void )
   4399          	{
   4400          		/* If xSemaphoreCreateMutex() is called before any tasks have been created
   4401          		then pxCurrentTCB will be NULL. */
   4402          		if( pxCurrentTCB != NULL )
   4403          		{
   4404          			( pxCurrentTCB->uxMutexesHeld )++;
   4405          		}
   4406          
   4407          		return pxCurrentTCB;
   4408          	}
   4409          
   4410          #endif /* configUSE_MUTEXES */
   4411          /*-----------------------------------------------------------*/
   4412          
   4413          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4414          
   4415          	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
   4416          	{
   4417          	uint32_t ulReturn;
   4418          
   4419          		taskENTER_CRITICAL();
   4420          		{
   4421          			/* Only block if the notification count is not already non-zero. */
   4422          			if( pxCurrentTCB->ulNotifiedValue == 0UL )
   4423          			{
   4424          				/* Mark this task as waiting for a notification. */
   4425          				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   4426          
   4427          				if( xTicksToWait > ( TickType_t ) 0 )
   4428          				{
   4429          					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   4430          					traceTASK_NOTIFY_TAKE_BLOCK();
   4431          
   4432          					/* All ports are written to allow a yield in a critical
   4433          					section (some will yield immediately, others wait until the
   4434          					critical section exits) - but it is not something that
   4435          					application code should ever do. */
   4436          					portYIELD_WITHIN_API();
   4437          				}
   4438          				else
   4439          				{
   4440          					mtCOVERAGE_TEST_MARKER();
   4441          				}
   4442          			}
   4443          			else
   4444          			{
   4445          				mtCOVERAGE_TEST_MARKER();
   4446          			}
   4447          		}
   4448          		taskEXIT_CRITICAL();
   4449          
   4450          		taskENTER_CRITICAL();
   4451          		{
   4452          			traceTASK_NOTIFY_TAKE();
   4453          			ulReturn = pxCurrentTCB->ulNotifiedValue;
   4454          
   4455          			if( ulReturn != 0UL )
   4456          			{
   4457          				if( xClearCountOnExit != pdFALSE )
   4458          				{
   4459          					pxCurrentTCB->ulNotifiedValue = 0UL;
   4460          				}
   4461          				else
   4462          				{
   4463          					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
   4464          				}
   4465          			}
   4466          			else
   4467          			{
   4468          				mtCOVERAGE_TEST_MARKER();
   4469          			}
   4470          
   4471          			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   4472          		}
   4473          		taskEXIT_CRITICAL();
   4474          
   4475          		return ulReturn;
   4476          	}
   4477          
   4478          #endif /* configUSE_TASK_NOTIFICATIONS */
   4479          /*-----------------------------------------------------------*/
   4480          
   4481          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4482          
   4483          	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
   4484          	{
   4485          	BaseType_t xReturn;
   4486          
   4487          		taskENTER_CRITICAL();
   4488          		{
   4489          			/* Only block if a notification is not already pending. */
   4490          			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
   4491          			{
   4492          				/* Clear bits in the task's notification value as bits may get
   4493          				set	by the notifying task or interrupt.  This can be used to
   4494          				clear the value to zero. */
   4495          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
   4496          
   4497          				/* Mark this task as waiting for a notification. */
   4498          				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   4499          
   4500          				if( xTicksToWait > ( TickType_t ) 0 )
   4501          				{
   4502          					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   4503          					traceTASK_NOTIFY_WAIT_BLOCK();
   4504          
   4505          					/* All ports are written to allow a yield in a critical
   4506          					section (some will yield immediately, others wait until the
   4507          					critical section exits) - but it is not something that
   4508          					application code should ever do. */
   4509          					portYIELD_WITHIN_API();
   4510          				}
   4511          				else
   4512          				{
   4513          					mtCOVERAGE_TEST_MARKER();
   4514          				}
   4515          			}
   4516          			else
   4517          			{
   4518          				mtCOVERAGE_TEST_MARKER();
   4519          			}
   4520          		}
   4521          		taskEXIT_CRITICAL();
   4522          
   4523          		taskENTER_CRITICAL();
   4524          		{
   4525          			traceTASK_NOTIFY_WAIT();
   4526          
   4527          			if( pulNotificationValue != NULL )
   4528          			{
   4529          				/* Output the current notification value, which may or may not
   4530          				have changed. */
   4531          				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
   4532          			}
   4533          
   4534          			/* If ucNotifyValue is set then either the task never entered the
   4535          			blocked state (because a notification was already pending) or the
   4536          			task unblocked because of a notification.  Otherwise the task
   4537          			unblocked because of a timeout. */
   4538          			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
   4539          			{
   4540          				/* A notification was not received. */
   4541          				xReturn = pdFALSE;
   4542          			}
   4543          			else
   4544          			{
   4545          				/* A notification was already pending or a notification was
   4546          				received while the task was waiting. */
   4547          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
   4548          				xReturn = pdTRUE;
   4549          			}
   4550          
   4551          			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   4552          		}
   4553          		taskEXIT_CRITICAL();
   4554          
   4555          		return xReturn;
   4556          	}
   4557          
   4558          #endif /* configUSE_TASK_NOTIFICATIONS */
   4559          /*-----------------------------------------------------------*/
   4560          
   4561          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4562          
   4563          	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
   4564          	{
   4565          	TCB_t * pxTCB;
   4566          	BaseType_t xReturn = pdPASS;
   4567          	uint8_t ucOriginalNotifyState;
   4568          
   4569          		configASSERT( xTaskToNotify );
   4570          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4571          
   4572          		taskENTER_CRITICAL();
   4573          		{
   4574          			if( pulPreviousNotificationValue != NULL )
   4575          			{
   4576          				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   4577          			}
   4578          
   4579          			ucOriginalNotifyState = pxTCB->ucNotifyState;
   4580          
   4581          			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   4582          
   4583          			switch( eAction )
   4584          			{
   4585          				case eSetBits	:
   4586          					pxTCB->ulNotifiedValue |= ulValue;
   4587          					break;
   4588          
   4589          				case eIncrement	:
   4590          					( pxTCB->ulNotifiedValue )++;
   4591          					break;
   4592          
   4593          				case eSetValueWithOverwrite	:
   4594          					pxTCB->ulNotifiedValue = ulValue;
   4595          					break;
   4596          
   4597          				case eSetValueWithoutOverwrite :
   4598          					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   4599          					{
   4600          						pxTCB->ulNotifiedValue = ulValue;
   4601          					}
   4602          					else
   4603          					{
   4604          						/* The value could not be written to the task. */
   4605          						xReturn = pdFAIL;
   4606          					}
   4607          					break;
   4608          
   4609          				case eNoAction:
   4610          					/* The task is being notified without its notify value being
   4611          					updated. */
   4612          					break;
   4613          			}
   4614          
   4615          			traceTASK_NOTIFY();
   4616          
   4617          			/* If the task is in the blocked state specifically to wait for a
   4618          			notification then unblock it now. */
   4619          			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   4620          			{
   4621          				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   4622          				prvAddTaskToReadyList( pxTCB );
   4623          
   4624          				/* The task should not have been on an event list. */
   4625          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4626          
   4627          				#if( configUSE_TICKLESS_IDLE != 0 )
   4628          				{
   4629          					/* If a task is blocked waiting for a notification then
   4630          					xNextTaskUnblockTime might be set to the blocked task's time
   4631          					out time.  If the task is unblocked for a reason other than
   4632          					a timeout xNextTaskUnblockTime is normally left unchanged,
   4633          					because it will automatically get reset to a new value when
   4634          					the tick count equals xNextTaskUnblockTime.  However if
   4635          					tickless idling is used it might be more important to enter
   4636          					sleep mode at the earliest possible time - so reset
   4637          					xNextTaskUnblockTime here to ensure it is updated at the
   4638          					earliest possible time. */
   4639          					prvResetNextTaskUnblockTime();
   4640          				}
   4641          				#endif
   4642          
   4643          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4644          				{
   4645          					/* The notified task has a priority above the currently
   4646          					executing task so a yield is required. */
   4647          					taskYIELD_IF_USING_PREEMPTION();
   4648          				}
   4649          				else
   4650          				{
   4651          					mtCOVERAGE_TEST_MARKER();
   4652          				}
   4653          			}
   4654          			else
   4655          			{
   4656          				mtCOVERAGE_TEST_MARKER();
   4657          			}
   4658          		}
   4659          		taskEXIT_CRITICAL();
   4660          
   4661          		return xReturn;
   4662          	}
   4663          
   4664          #endif /* configUSE_TASK_NOTIFICATIONS */
   4665          /*-----------------------------------------------------------*/
   4666          
   4667          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4668          
   4669          	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
   4670          	{
   4671          	TCB_t * pxTCB;
   4672          	uint8_t ucOriginalNotifyState;
   4673          	BaseType_t xReturn = pdPASS;
   4674          	UBaseType_t uxSavedInterruptStatus;
   4675          
   4676          		configASSERT( xTaskToNotify );
   4677          
   4678          		/* RTOS ports that support interrupt nesting have the concept of a
   4679          		maximum	system call (or maximum API call) interrupt priority.
   4680          		Interrupts that are	above the maximum system call priority are keep
   4681          		permanently enabled, even when the RTOS kernel is in a critical section,
   4682          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4683          		is defined in FreeRTOSConfig.h then
   4684          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4685          		failure if a FreeRTOS API function is called from an interrupt that has
   4686          		been assigned a priority above the configured maximum system call
   4687          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4688          		from interrupts	that have been assigned a priority at or (logically)
   4689          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4690          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4691          		simple as possible.  More information (albeit Cortex-M specific) is
   4692          		provided on the following link:
   4693          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4694          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   4695          
   4696          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4697          
   4698          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   4699          		{
   4700          			if( pulPreviousNotificationValue != NULL )
   4701          			{
   4702          				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   4703          			}
   4704          
   4705          			ucOriginalNotifyState = pxTCB->ucNotifyState;
   4706          			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   4707          
   4708          			switch( eAction )
   4709          			{
   4710          				case eSetBits	:
   4711          					pxTCB->ulNotifiedValue |= ulValue;
   4712          					break;
   4713          
   4714          				case eIncrement	:
   4715          					( pxTCB->ulNotifiedValue )++;
   4716          					break;
   4717          
   4718          				case eSetValueWithOverwrite	:
   4719          					pxTCB->ulNotifiedValue = ulValue;
   4720          					break;
   4721          
   4722          				case eSetValueWithoutOverwrite :
   4723          					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   4724          					{
   4725          						pxTCB->ulNotifiedValue = ulValue;
   4726          					}
   4727          					else
   4728          					{
   4729          						/* The value could not be written to the task. */
   4730          						xReturn = pdFAIL;
   4731          					}
   4732          					break;
   4733          
   4734          				case eNoAction :
   4735          					/* The task is being notified without its notify value being
   4736          					updated. */
   4737          					break;
   4738          			}
   4739          
   4740          			traceTASK_NOTIFY_FROM_ISR();
   4741          
   4742          			/* If the task is in the blocked state specifically to wait for a
   4743          			notification then unblock it now. */
   4744          			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   4745          			{
   4746          				/* The task should not have been on an event list. */
   4747          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4748          
   4749          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   4750          				{
   4751          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   4752          					prvAddTaskToReadyList( pxTCB );
   4753          				}
   4754          				else
   4755          				{
   4756          					/* The delayed and ready lists cannot be accessed, so hold
   4757          					this task pending until the scheduler is resumed. */
   4758          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   4759          				}
   4760          
   4761          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4762          				{
   4763          					/* The notified task has a priority above the currently
   4764          					executing task so a yield is required. */
   4765          					if( pxHigherPriorityTaskWoken != NULL )
   4766          					{
   4767          						*pxHigherPriorityTaskWoken = pdTRUE;
   4768          					}
   4769          					else
   4770          					{
   4771          						/* Mark that a yield is pending in case the user is not
   4772          						using the "xHigherPriorityTaskWoken" parameter to an ISR
   4773          						safe FreeRTOS function. */
   4774          						xYieldPending = pdTRUE;
   4775          					}
   4776          				}
   4777          				else
   4778          				{
   4779          					mtCOVERAGE_TEST_MARKER();
   4780          				}
   4781          			}
   4782          		}
   4783          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   4784          
   4785          		return xReturn;
   4786          	}
   4787          
   4788          #endif /* configUSE_TASK_NOTIFICATIONS */
   4789          /*-----------------------------------------------------------*/
   4790          
   4791          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4792          
   4793          	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
   4794          	{
   4795          	TCB_t * pxTCB;
   4796          	uint8_t ucOriginalNotifyState;
   4797          	UBaseType_t uxSavedInterruptStatus;
   4798          
   4799          		configASSERT( xTaskToNotify );
   4800          
   4801          		/* RTOS ports that support interrupt nesting have the concept of a
   4802          		maximum	system call (or maximum API call) interrupt priority.
   4803          		Interrupts that are	above the maximum system call priority are keep
   4804          		permanently enabled, even when the RTOS kernel is in a critical section,
   4805          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4806          		is defined in FreeRTOSConfig.h then
   4807          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4808          		failure if a FreeRTOS API function is called from an interrupt that has
   4809          		been assigned a priority above the configured maximum system call
   4810          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4811          		from interrupts	that have been assigned a priority at or (logically)
   4812          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4813          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4814          		simple as possible.  More information (albeit Cortex-M specific) is
   4815          		provided on the following link:
   4816          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4817          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   4818          
   4819          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4820          
   4821          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   4822          		{
   4823          			ucOriginalNotifyState = pxTCB->ucNotifyState;
   4824          			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   4825          
   4826          			/* 'Giving' is equivalent to incrementing a count in a counting
   4827          			semaphore. */
   4828          			( pxTCB->ulNotifiedValue )++;
   4829          
   4830          			traceTASK_NOTIFY_GIVE_FROM_ISR();
   4831          
   4832          			/* If the task is in the blocked state specifically to wait for a
   4833          			notification then unblock it now. */
   4834          			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   4835          			{
   4836          				/* The task should not have been on an event list. */
   4837          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4838          
   4839          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   4840          				{
   4841          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   4842          					prvAddTaskToReadyList( pxTCB );
   4843          				}
   4844          				else
   4845          				{
   4846          					/* The delayed and ready lists cannot be accessed, so hold
   4847          					this task pending until the scheduler is resumed. */
   4848          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   4849          				}
   4850          
   4851          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4852          				{
   4853          					/* The notified task has a priority above the currently
   4854          					executing task so a yield is required. */
   4855          					if( pxHigherPriorityTaskWoken != NULL )
   4856          					{
   4857          						*pxHigherPriorityTaskWoken = pdTRUE;
   4858          					}
   4859          					else
   4860          					{
   4861          						/* Mark that a yield is pending in case the user is not
   4862          						using the "xHigherPriorityTaskWoken" parameter in an ISR
   4863          						safe FreeRTOS function. */
   4864          						xYieldPending = pdTRUE;
   4865          					}
   4866          				}
   4867          				else
   4868          				{
   4869          					mtCOVERAGE_TEST_MARKER();
   4870          				}
   4871          			}
   4872          		}
   4873          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   4874          	}
   4875          
   4876          #endif /* configUSE_TASK_NOTIFICATIONS */
   4877          
   4878          /*-----------------------------------------------------------*/
   4879          
   4880          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4881          
   4882          	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
   4883          	{
   4884          	TCB_t *pxTCB;
   4885          	BaseType_t xReturn;
   4886          
   4887          		/* If null is passed in here then it is the calling task that is having
   4888          		its notification state cleared. */
   4889          		pxTCB = prvGetTCBFromHandle( xTask );
   4890          
   4891          		taskENTER_CRITICAL();
   4892          		{
   4893          			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
   4894          			{
   4895          				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   4896          				xReturn = pdPASS;
   4897          			}
   4898          			else
   4899          			{
   4900          				xReturn = pdFAIL;
   4901          			}
   4902          		}
   4903          		taskEXIT_CRITICAL();
   4904          
   4905          		return xReturn;
   4906          	}
   4907          
   4908          #endif /* configUSE_TASK_NOTIFICATIONS */
   4909          /*-----------------------------------------------------------*/
   4910          
   4911          
   4912          static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
   4913          {
   4914          TickType_t xTimeToWake;
   4915          const TickType_t xConstTickCount = xTickCount;
   4916          
   4917          	#if( INCLUDE_xTaskAbortDelay == 1 )
   4918          	{
   4919          		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
   4920          		reset to pdFALSE so it can be detected as having been set to pdTRUE
   4921          		when the task leaves the Blocked state. */
   4922          		pxCurrentTCB->ucDelayAborted = pdFALSE;
   4923          	}
   4924          	#endif
   4925          
   4926          	/* Remove the task from the ready list before adding it to the blocked list
   4927          	as the same list item is used for both lists. */
   4928          	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   4929          	{
   4930          		/* The current task must be in a ready list, so there is no need to
   4931          		check, and the port reset macro can be called directly. */
   4932          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   4933          	}
   4934          	else
   4935          	{
   4936          		mtCOVERAGE_TEST_MARKER();
   4937          	}
   4938          
   4939          	#if ( INCLUDE_vTaskSuspend == 1 )
   4940          	{
   4941          		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   4942          		{
   4943          			/* Add the task to the suspended task list instead of a delayed task
   4944          			list to ensure it is not woken by a timing event.  It will block
   4945          			indefinitely. */
   4946          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   4947          		}
   4948          		else
   4949          		{
   4950          			/* Calculate the time at which the task should be woken if the event
   4951          			does not occur.  This may overflow but this doesn't matter, the
   4952          			kernel will manage it correctly. */
   4953          			xTimeToWake = xConstTickCount + xTicksToWait;
   4954          
   4955          			/* The list item will be inserted in wake time order. */
   4956          			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   4957          
   4958          			if( xTimeToWake < xConstTickCount )
   4959          			{
   4960          				/* Wake time has overflowed.  Place this item in the overflow
   4961          				list. */
   4962          				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   4963          			}
   4964          			else
   4965          			{
   4966          				/* The wake time has not overflowed, so the current block list
   4967          				is used. */
   4968          				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   4969          
   4970          				/* If the task entering the blocked state was placed at the
   4971          				head of the list of blocked tasks then xNextTaskUnblockTime
   4972          				needs to be updated too. */
   4973          				if( xTimeToWake < xNextTaskUnblockTime )
   4974          				{
   4975          					xNextTaskUnblockTime = xTimeToWake;
   4976          				}
   4977          				else
   4978          				{
   4979          					mtCOVERAGE_TEST_MARKER();
   4980          				}
   4981          			}
   4982          		}
   4983          	}
   4984          	#else /* INCLUDE_vTaskSuspend */
   4985          	{
   4986          		/* Calculate the time at which the task should be woken if the event
   4987          		does not occur.  This may overflow but this doesn't matter, the kernel
   4988          		will manage it correctly. */
   4989          		xTimeToWake = xConstTickCount + xTicksToWait;
   4990          
   4991          		/* The list item will be inserted in wake time order. */
   4992          		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   4993          
   4994          		if( xTimeToWake < xConstTickCount )
   4995          		{
   4996          			/* Wake time has overflowed.  Place this item in the overflow list. */
   4997          			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   4998          		}
   4999          		else
   5000          		{
   5001          			/* The wake time has not overflowed, so the current block list is used. */
   5002          			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   5003          
   5004          			/* If the task entering the blocked state was placed at the head of the
   5005          			list of blocked tasks then xNextTaskUnblockTime needs to be updated
   5006          			too. */
   5007          			if( xTimeToWake < xNextTaskUnblockTime )
   5008          			{
   5009          				xNextTaskUnblockTime = xTimeToWake;
   5010          			}
   5011          			else
   5012          			{
   5013          				mtCOVERAGE_TEST_MARKER();
   5014          			}
   5015          		}
   5016          
   5017          		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
   5018          		( void ) xCanBlockIndefinitely;
   5019          	}
   5020          	#endif /* INCLUDE_vTaskSuspend */
   5021          }
   5022          
   5023          /* Code below here allows additional code to be inserted into this source file,
   5024          especially where access to file scope functions and data is needed (for example
   5025          when performing module tests). */
   5026          
   5027          #ifdef FREERTOS_MODULE_TEST
   5028          	#include "tasks_test_access_functions.h"
   5029          #endif
   5030          
   5031          
   5032          #if( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )
   5033          
   5034          	#include "freertos_tasks_c_additions.h"
   5035          
   5036          	static void freertos_tasks_c_additions_init( void )
   5037          	{
   5038          		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
   5039          			FREERTOS_TASKS_C_ADDITIONS_INIT();
   5040          		#endif
   5041          	}
   5042          
   5043          #endif
   5044          
   5045          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   pcTaskGetName
      16   prvAddCurrentTaskToDelayedList
        16   -> uxListRemove
        16   -> vListInsert
        16   -> vListInsertEnd
       8   prvAddNewTaskToReadyList
         8   -> prvInitialiseTaskLists
         8   -> vListInsertEnd
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   prvCheckTasksWaitingTermination
         8   -> prvDeleteTCB
         8   -> uxListRemove
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   prvDeleteTCB
         8   -> vPortFree
       8   prvIdleTask
         8   -> prvCheckTasksWaitingTermination
      24   prvInitialiseNewTask
        24   -> pxPortInitialiseStack
        24   -> vListInitialiseItem
       8   prvInitialiseTaskLists
         8   -> vListInitialise
       0   prvResetNextTaskUnblockTime
       0   prvTaskIsTaskSuspended
      16   ulTaskNotifyTake
        16   -> prvAddCurrentTaskToDelayedList
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       0   uxTaskGetNumberOfTasks
       8   uxTaskPriorityGet
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       0   uxTaskPriorityGetFromISR
       0   uxTaskResetEventItemValue
       8   vTaskDelay
         8   -> prvAddCurrentTaskToDelayedList
         8   -> vTaskSuspendAll
         8   -> xTaskResumeAll
      16   vTaskDelayUntil
        16   -> prvAddCurrentTaskToDelayedList
        16   -> vTaskSuspendAll
        16   -> xTaskResumeAll
       8   vTaskDelete
         8   -> prvDeleteTCB
         8   -> prvResetNextTaskUnblockTime
         8   -> uxListRemove
         8   -> vListInsertEnd
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   vTaskEndScheduler
         8   -> vPortEndScheduler
       0   vTaskInternalSetTimeOutState
       0   vTaskMissedYield
      16   vTaskNotifyGiveFromISR
        16   -> uxListRemove
        16   -> vListInsertEnd
       8   vTaskPlaceOnEventList
         8   -> prvAddCurrentTaskToDelayedList
         8   -> vListInsert
       8   vTaskPlaceOnUnorderedEventList
         8   -> prvAddCurrentTaskToDelayedList
         8   -> vListInsertEnd
      24   vTaskPrioritySet
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
       8   vTaskRemoveFromUnorderedEventList
         8   -> uxListRemove
         8   -> vListInsertEnd
       8   vTaskResume
         8   -> prvTaskIsTaskSuspended
         8   -> uxListRemove
         8   -> vListInsertEnd
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   vTaskSetTimeOutState
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      16   vTaskStartScheduler
        16   -> xPortStartScheduler
        16   -> xTaskCreate
       8   vTaskSuspend
         8   -> prvResetNextTaskUnblockTime
         8   -> uxListRemove
         8   -> vListInsertEnd
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
         8   -> vTaskSwitchContext
       0   vTaskSuspendAll
       0   vTaskSwitchContext
      16   xTaskCheckForTimeOut
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskInternalSetTimeOutState
      48   xTaskCreate
        48   -> prvAddNewTaskToReadyList
        48   -> prvInitialiseNewTask
        48   -> pvPortMalloc
        48   -> vPortFree
      24   xTaskGenericNotify
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      16   xTaskGenericNotifyFromISR
        16   -> uxListRemove
        16   -> vListInsertEnd
       0   xTaskGetTickCount
       0   xTaskGetTickCountFromISR
      16   xTaskIncrementTick
        16   -> prvResetNextTaskUnblockTime
        16   -> uxListRemove
        16   -> vListInsertEnd
       8   xTaskNotifyStateClear
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      24   xTaskNotifyWait
        24   -> prvAddCurrentTaskToDelayedList
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
       8   xTaskRemoveFromEventList
         8   -> uxListRemove
         8   -> vListInsertEnd
      16   xTaskResumeAll
        16   -> prvResetNextTaskUnblockTime
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> xTaskIncrementTick
      16   xTaskResumeFromISR
        16   -> prvTaskIsTaskSuspended
        16   -> uxListRemove
        16   -> vListInsertEnd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable34_3
       4  ??DataTable34_4
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_2
       4  ??DataTable36
       4  ??DataTable37
       4  ??DataTable39
       4  ??DataTable40
       4  ??DataTable40_1
       4  ??DataTable40_10
       4  ??DataTable40_11
       4  ??DataTable40_12
       4  ??DataTable40_13
       4  ??DataTable40_14
       4  ??DataTable40_15
       4  ??DataTable40_16
       4  ??DataTable40_17
       4  ??DataTable40_2
       4  ??DataTable40_3
       4  ??DataTable40_4
       4  ??DataTable40_5
       4  ??DataTable40_6
       4  ??DataTable40_7
       4  ??DataTable40_8
       4  ??DataTable40_9
       8  ?_0
      16  pcTaskGetName
     128  prvAddCurrentTaskToDelayedList
     184  prvAddNewTaskToReadyList
      60  prvCheckTasksWaitingTermination
      18  prvDeleteTCB
      34  prvIdleTask
     130  prvInitialiseNewTask
      86  prvInitialiseTaskLists
      44  prvResetNextTaskUnblockTime
      34  prvTaskIsTaskSuspended
       4  pxCurrentTCB
       4  pxDelayedTaskList
       4  pxOverflowDelayedTaskList
     100  pxReadyTasksLists
     128  ulTaskNotifyTake
       4  uxCurrentNumberOfTasks
       4  uxDeletedTasksWaitingCleanUp
       4  uxPendedTicks
       4  uxSchedulerSuspended
       8  uxTaskGetNumberOfTasks
       4  uxTaskNumber
      30  uxTaskPriorityGet
      38  uxTaskPriorityGetFromISR
      30  uxTaskResetEventItemValue
       4  uxTopReadyPriority
      50  vTaskDelay
      96  vTaskDelayUntil
     198  vTaskDelete
      30  vTaskEndScheduler
      18  vTaskInternalSetTimeOutState
      10  vTaskMissedYield
     138  vTaskNotifyGiveFromISR
      26  vTaskPlaceOnEventList
      38  vTaskPlaceOnUnorderedEventList
     206  vTaskPrioritySet
      74  vTaskRemoveFromUnorderedEventList
     114  vTaskResume
      30  vTaskSetTimeOutState
      80  vTaskStartScheduler
     202  vTaskSuspend
      16  vTaskSuspendAll
      84  vTaskSwitchContext
      20  xDelayedTaskList1
      20  xDelayedTaskList2
       4  xIdleTaskHandle
       4  xNextTaskUnblockTime
       4  xNumOfOverflows
      20  xPendingReadyList
       4  xSchedulerRunning
      20  xSuspendedTaskList
      88  xTaskCheckForTimeOut
     118  xTaskCreate
     176  xTaskGenericNotify
     198  xTaskGenericNotifyFromISR
       8  xTaskGetTickCount
      10  xTaskGetTickCountFromISR
     262  xTaskIncrementTick
      46  xTaskNotifyStateClear
     146  xTaskNotifyWait
     104  xTaskRemoveFromEventList
     224  xTaskResumeAll
     126  xTaskResumeFromISR
      20  xTasksWaitingTermination
       4  xTickCount
       4  xYieldPending

 
   260 bytes in section .bss
     8 bytes in section .rodata
 4 000 bytes in section .text
 
 4 000 bytes of CODE  memory
     8 bytes of CONST memory
   260 bytes of DATA  memory

Errors: none
Warnings: none
